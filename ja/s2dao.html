<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- don't edit start -->
<head>
<title>S2Dao - リファレンス</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<link href="seasar_b.css" type="text/css" rel="stylesheet" media="screen" />
<link href="seasar_p.css" type="text/css" rel="stylesheet" media="print" />
<script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head>
<body onload="preload('ja')">
<table width="100%" border="0" cellspacing="0" cellpadding="0" align="left"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3"><img height="117" width="256" src="images/spacer.gif" alt=""></td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="http://www.seasar.org/index.html"><img src="images/menu01_b_ja.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td><a href="http://www.seasar.org/projects.html"><img src="images/menu02_b_ja.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td><a href="http://www.seasar.org/products.html"><img src="images/menu03_b_ja.gif" height="30" width="110" border="0" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)"></a></td>
<td><a href="http://www.seasar.org/resources.html"><img src="images/menu04_b_ja.gif" height="30" width="113" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td><img src="images/menu05_b_ja.gif" height="30" width="109" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></td>
<td><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>
<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr align="left" valign="top"><td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td><td width="752" class="main">
<!-- don't edit end -->
<!-- document start -->
	<ul>
		<li><a href="#S2Daoリファレンス">S2Daoリファレンス</a>
        	<ul>
				<li><a href="#SetUp">セットアップ</a></li>
                <li><a href="#DaoMakeFile">作成すべきファイル</a></li>
                	<ul>
                		<li type="circle"><a href="#JavaBeans">JavaBeans</a></li>
							<ul>
								<li><a href="#TableAnnotation">TABLEアノテーション</a></li>
								<li><a href="#ColumnAnnotation">COLUMNアノテーション</a></li>
								<li><a href="#N1Mapping">N:1マッピング</a></li>
								<li><a href="#IDAutoGenerate">IDの自動生成</a></li>
								<li><a href="#NoPersistentColumns">永続化されないカラム</a></li>
								<li><a href="#VersionNoPropertyAnnotation">VERSION_NO_PROPERTYアノテーション</a></li>
								<li><a href="#TimestampPropertyAnnotation">TIMESTAMP_PROPERTYアノテーション</a></li>
								<li><a href="#property">カラムに対応するプロパティの宣言</a></li>
								<li><a href="#GetterSetterMethod">getter/setterメソッドの実装</a></li>
							</ul>
                		<li type="circle"><a href="#Dao">Dao(Data Access Object)</a></li>
							<ul>
								<li><a href="#BeanAnnotation">BEANアノテーション</a></li>
								<li><a href="#ArgsAnnotation">ARGSアノテーション</a></li>
								<li><a href="#QueryAnnotation">QUERYアノテーション</a></li>
								<li><a href="#DefMethod">メソッドの定義</a></li>
								<li><a href="#NoPersistentPropsAnnotation">NO_PERSISTENT_PROPSアノテーション</a></li>
								<li><a href="#PersistentPropsAnnotation">PERSISTENT_PROPSアノテーション</a></li>
								<li><a href="#SqlAnnotation">SQLアノテーション</a></li>
								<li><a href="#ProcedureAnnotation">PROCEDUREアノテーション</a></li>
							</ul>
                		<li type="circle"><a href="#diconfile">diconファイル</a></li>
                		<li type="circle"><a href="#SQLfile">SQLファイル</a></li>
                	</ul>
                <li><a href="#SQLBind">SQLコメント</a></li>
                <li><a href="#EntityManager">EntityManagerを使用したQueryの実行</a></li>
				<li><a href="#AutoUpdate">更新SQLの自動生成</a></li>
				<li><a href="#VersionNo">VersionNoによる排他制御 </a></li>
				<li><a href="#Timestamp">Timestampによる排他制御 </a></li>
				<li><a href="#Batch">バッチ更新</a></li>
				<li><a href="#AutoSelect">検索SQLの自動生成 </a></li>
				<li><a href="#IDAutoGenerate">IDの自動生成 </a></li>
				<li><a href="#CLOBType">CLOB型とのマッピング</a></li>
				<li><a href="#HowToRun">S2Daoの実行</a></li>
	        	<li><a href="http://s2container.seasar.org/ja/testtech.html#S2DaoTestCase">S2DaoTestCase</a></li>
	        	<li><a href="http://s2container.seasar.org/ja/s2jdbc.html#OracleUnicode">OracleのUnicode問題</a></li>
				<li><a href="http://s2container.seasar.org/ja/s2jdbc.html#BooleanToInt">Booleanの扱い</a></li>
			</ul>
		</li>
		<li><a href="#Example">Example</a>
			<ul>
                <li><a href="#SelectExample">SQL文を記述する場合のExample</a></li>
        		<li><a href="#AutoUpdateExample">自動で更新用SQL文を生成する場合のExample</a></li>
                <li><a href="#AutoSelectExample">自動で検索用SQL文を生成する場合のExample</a></li>
        		<li><a href="#EntityManagerExample">EntityManagerを使用したExample</a></li>
        		<li><a href="http://s2container.seasar.org/ja/testtech.html#S2DaoTestCaseExample">S2DaoTestCaseのExample</a></li>
            </ul>
    	</li>
    	<li><a href="s2DaoExercise.html">S2Daoエクササイズ</a></li>
	</ul>

	<h2><a name="S2Daoリファレンス">S2Daoリファレンス</a></h2>
	<h3><a name="SetUp">セットアップ</a></h3>
		<p>Seasar2と同様にJDK1.4以上が必要です。s2-dao-x.x.x.zipを解凍してできたs2daoディレクトリを、Eclipseで
		｢ファイル→インポート→既存のプロジェクトをワークスペースへ｣でインポートしてください。Seasar2の必要なバージョンは、<a href="http://www.seasar.org/wiki/index.php?Versions#j388ac47">Wiki</a>をご覧ください。
		s2-dao-examples/src/main/java配下にサンプルもあります。
		</p>
		<p>S2Daoとして必要なjarファイルは、1.0.41以降はlib/の下に全てそろっています。それ以前のバージョンは、<a href="http://s2container.seasar.org/ja/setup.html">Seasar2で必要なjarファイル全て</a>とSeasar2の(s2-framework/s2-extension)本体が必要です。です。簡単に機能を試すことができるように、RDBMSとしてHSQLDBを用意しています。
		lib/hsqldb.jarはHSQLDBを実行する上では必要ですが、本番では必要ありません。
		lib/s2-framework-2.3.xx-sources.jarとs2-extension-2.3.xx-sources.jarは、Eclipse上でソースを参照するためのもので、動作には必要ありません。
		libのjarファイル(hsqldb.jar以外)とsrcのj2ee.dicon(Seasar2.4の場合はjdbc.dicon)、<a href="#dao.dicon">dao.dicon(※後述)</a>をCLASSPATHにとおせば、S2Daoを実行できます。Eclipseにインポートして使う場合は設定は不要です。</p>
	<h4><a name="dao.dicon">dao.dicon</a></h4>
		<p>dao.diconはS2Daoの動作を設定するファイルです。
		1.0.36からはs2-dao-x.x.x.jarへ含まれるようになるので、明示的に配置する必要はなくなります。
		dao.diconをカスタマイズする場合は、カスタマイズしたdao.diconをs2-dao-x.x.x.jarより優先度の高いclasspathへ配置するなどして、
		カスタマイズした側が使用されるようにしてください。
		</p>
	<h4><a name="j2ee.dicon">j2ee.dicon</a></h4>
		<p>S2Pagerの機能を使用する場合には、j2ee.diconを修正する必要があります(v1.0.36以降はデフォルトで有効になっています)。
		具体的な設定内容は<a href="s2pager.html">S2Pagerのドキュメント</a>を
		ご覧ください。
		</p>

    <h3><a name="DaoMakeFile">作成すべきファイル</a></h3>
	    <p>S2Dao機能を使用するにあたり、JavaBeans、Dao(.java)、diconファイル、SQLファイル(.sql)の作成が必要となります。
	    <br />各ファイルの関連イメージ図は次のようになります。</p>
	    <img src="./images/dao_relation_image.gif" />
	    <p>JavaBeansはテーブル、DaoはJavaBeans、diconファイルはDao、SQLファイルはDaoとそれぞれ関連しています。<br />
	    各ファイルの実装・設定方法の詳細は次のようになります。</p>

    <h4><a name="JavaBeans">JavaBeans</a></h4>
    	<p>
    	JavaBeansはテーブルとの関連付けに使用します。
		JavaBeansにテーブルの関連付けを行うには、以下の定数宣言とメソッドの実装が必要になります。</p>
		<ul>
		<li>テーブルとの関連付けの定数宣言</li>
			(<a href="#TableAnnotation">TABLEアノテーション</a>)
		<li>カラムとの関連付けの定数宣言</li>
			(<a href="#ColumnAnnotation">COLUMNアノテーション</a>)
		<li>別テーブルと結合する場合はキーとなる定数宣言</li>
			(<a href="#N1Mapping">N:1マッピング</a>)
		<li><a href="#IDAutoGenerate">IDの自動生成</a></li>
		<li><a href="#NoPersistentColumns">永続化されないカラム</a></li>
		<li><a href="#property">カラムに対応するプロパティの宣言</a></il>
		<li><a href="#GetterSetterMethod">getter/setterメソッドの実装</a></li>
		</ul>
		<p>JavaBeansの構成と説明内で使用するテーブルは以下の通りです。</p>
		テーブル：EMP<br />
		<table border="1" class="main">
			<tr bgcolor="#d1f3f4" align="center">
			  <th>カラム名</th>
			  <th>型</th>
			  <th>NotNull</th>
			  <th>主キー</th>
			</tr>
			<tr>
			  <td>EMPNO</td>
			  <td>NUMBER</td>
			  <td align="center">〇</td>
			  <td align="center">〇</td>
			</tr>
			<tr>
			  <td>ENAME</td>
			  <td>VARCHAR</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>DEPTNUM</td>
			  <td>NUMBER</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
		</table>
	   <br />
	  	テーブル：DEPT<br />
		<table border="1" class="main">
			<tr bgcolor="#d1f3f4" align="center">
			  <th>カラム名</th>
			  <th>型</th>
			  <th>NotNull</th>
			  <th>主キー</th>
			</tr>
			<tr>
			  <td>DEPTNO</td>
			  <td>NUMBER</td>
			  <td align="center">〇</td>
			  <td align="center">〇</td>
			</tr>
			<tr>
			  <td>DNAME</td>
			  <td>VARCHAR</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
		</table>
    <h5><a name="TableAnnotation">TABLEアノテーション</a></h5>
    	<p>テーブルとの関連付けはTABLEアノテーションを使用します。
		TABLEアノテーションは以下の形式で定数を宣言します。</p>
		<p> -  public static final String TABLE = “<span class="italic">テーブル名</span>”;</p>
		<p>EMPテーブルの場合以下のようになります。</p>
		<pre>public static final String TABLE = "EMP";</pre>
		<p>スキーマの定義をすることも可能です。スキーマ名が"SCOTT"の場合は以下のようになります。</p>
		<pre>public static final String TABLE = "SCOTT.EMP";</pre>
    	※クラス名からパッケージ名を除いた名前がテーブル名と一致する場合は、TABLEアノテーションを定義する必要はありません。

     <h5><a name="ColumnAnnotation">COLUMNアノテーション</a></h5>
    	<p>テーブルのカラムとの関連付けはCOLUMNアノテーションを使用します。<br />
		COLUMNアノテーションは以下の形式で定数を宣言します。</p>
		<p>-  public static final String <span class="italic">プロパティ名</span>_COLUMN = "<span class="italic">カラム名</span>";</p>
		employeeNoというプロパティにEMPNOカラムを関連付けする場合以下のようになります。
		<pre>public static final String employeeNo_COLUMN = "EMPNO";</pre>
    	※プロパティ名とカラム名が一致する場合は、COLUMNアノテーションを定義する必要はありません。
		テーブルに存在しないプロパティは、自動的に無視されるので、特に何か定義する必要はありません。

     <h5><a name="N1Mapping">N:1マッピング</a></h5>
	     <p>N:1マッピングとは、複数の従業員の行に1つの部署の行が関連付けられるような場合のマッピングです。<br />
		 N:1マッピングを使用するには、RELNO定数とRELKEYS定数をそれぞれ宣言する必要があります。<br />
	     RELNO定数は以下の形式になります。</p>
		<p>-  public static final int <span class="italic">プロパティ名</span>_RELNO = <span class="italic">数値</span>;</p>
		<p>RELNO定数は、N:1マッピングの連番です。<br />
		例えば、AAAのテーブルにBBB,CCCのテーブルがN:1マッピングされるとするとBBBのRELNOは0、CCCのRELNOは1になります。 <br />
		RELNOは結果セットに含まれているカラムが、どのテーブルに所属しているのかを判定することに使われます。<br />
		例えば、SELECT ..., BBB.HOGE AS HOGE_0, ... FROM AAA, BBB ...のようなSELECT文があった場合、 HOGE_0はBBBテーブルに含まれているHOGEカラムであると認識されます。<br />
		RELKEYS定数は以下の形式になります。</p>
		<p>-  public static final String <span class="italic">プロパティ名</span>_RELKEYS = "<span class="italic">N側のテーブルのカラム名: 1側のテーブルのカラム名</span>";</p>
		<p>N:1マッピングのキーはRELKEYS定数で指定します。
		キーが複数ある場合には、カンマ( , )で区切ります。例えば、mykey1:yourkey1, mykey2:yourkey2のようにします。<br />
		EMPテーブルのDEPTNUMカラムとDEPTテーブルのDEPTNOを関連付ける場合は以下のようになります。</p>
<pre>
public static final int department_RELNO = 0;
public static final String department_RELKEYS = "DEPTNUM:DEPTNO";
</pre>
		<p>1側のテーブルのカラム名がN側のテーブルのカラム名に等しい場合は、1側のテーブルのカラム名を省略することができます。
		その場合以下のように定義することが出来ます。</p>
<pre>public static final String department_RELKEYS = "DEPTNO";</pre>
		<p>また1側のテーブルのカラム名とN側のテーブルのカラム名に等しく、1側のテーブルのカラム名がプライマリーキーの場合、RELKEYS定数を省略することができます。</p>

	<h5><a name="IDAutoGenerate">IDの自動生成</a></h5>
	<p>ID(プライマリーキー)をRDBMSに自動生成させて、自動生成された値をBeanに自動的に設定することが出来ます。そのために使うのが、IDアノテーションです。IDアノテーションは、プロパティ名_ID = &quot;identity&quot;のように指定します。 </p>
<pre>public static final String id_ID = "identity";</pre>
	<p>SEQUENCEを使うことも出来ます。myseqの部分は、実際のSEQUENCEに置き換えてください。</p>
<pre>
public static final String id_ID = "sequence, sequenceName=myseq";
</pre>
	<p>手動でIDを設定する場合は、何も指定する必要がありません。テーブルのプライマリーキーだという情報は、テーブルの定義(JDBCのメタデータ)より自動的に取得されます。また、明示的にassignedを指定することもできます。</p>
<pre>
public static final String id_ID = "assigned";
</pre>
	<p>IDアノテーションを、RDBMSごとに切り替えて使うことができます(1.0.41以降)。例えば、Identityにのみ対応するMySQLではIdentityを使い、SEQUENCEにのみ対応するOracleではSEQUENCEを使うことができます。</p>
<pre>
public static final String id_mysql_ID = "identity";
public static final String id_oracle_ID = "sequence, sequenceName=myseq";
</pre>
	<p>指定したRDB以外のデフォルト値を指定することもできます。(1.0.41以降)</p>
<pre>
public static final String id_mysql_ID = "identity";
public static final String id_ID = "sequence, sequenceName=myseq";
</pre>
	<p>RDBMSのサフィックスと、使用できるIDの取得方法は、表の通りです。</p>
		<table border="1" class="main">
			<tr bgcolor="#d1f3f4" align="center">
				<th scope="col">DBMS</th>
				<th scope="col">サフィックス</th>
				<th scope="col">Identity</th>
				<th scope="col">SEQUENCE</th>
			</tr>
			<tr>
				<td>Oracle</td>
				<td>oracle</td>
				<td>×</td>
				<td>○</td>
			</tr>
			<tr>
				<td>DB2</td>
				<td>db2</td>
				<td>○</td>
				<td>○</td>
			</tr>
			<tr>
				<td>MSSQLServer</td>
				<td>mssql</td>
				<td>○</td>
				<td>×</td>
			</tr>
			<tr>
				<td>MySQL</td>
				<td>mysql</td>
				<td>○</td>
				<td>×</td>
			</tr>
			<tr>
				<td>PostgreSQL</td>
				<td>postgre</td>
				<td>×</td>
				<td>○</td>
			</tr>
			<tr>
				<td>Firebird</td>
				<td>firebird</td>
				<td>×</td>
				<td>○</td>
			</tr>
			<tr>
				<td>MaxDB</td>
				<td>maxdb</td>
				<td>×</td>
				<td>○</td>
			</tr>
			<tr>
				<td>HSQL</td>
				<td>hsql</td>
				<td>○</td>
				<td>○</td>
			</tr>
			<tr>
				<td>Derby</td>
				<td>derby</td>
				<td>○</td>
				<td>○</td>
			</tr>
			<tr>
				<td>H2</td>
				<td>h2</td>
				<td>○</td>
				<td>○</td>
			</tr>
			<tr>
				<td>その他DB</td>
				<td>なし</td>
				<td>×</td>
				<td>×</td>
			</tr>
		</table>
	<h5><a name="CLOBType">CLOB型とのマッピング</a></h5>
<p>
JavaBeansのString型プロパティをテーブルのCLOB型と対応付けるには、VALUE_TYPEアノテーションを使用します。
下記の例では、"aaa"プロパティをCLOB型と対応付けています。
</p>
<pre>
// JavaBeans
public static String aaa_VALUE_TYPE = "stringClobType";
private String aaa;
public String getAaa() {
    return aaa;
}
public void setAaa(String aaa) {
    this.aaa = aaa;
}
</pre>
<pre>
&lt;!-- xxx.dicon --&gt;
&lt;component name="stringClobType" class="org.seasar.extension.jdbc.types.StringClobType" /&gt;
</pre>
diconで指定している"StringClobType.class"が、JavaとRDBMS間の型変換を行うクラスです。
VALUE_TYPEアノテーションには、diconで設定したコンポーネント名を記述します。

	<h5><a name="NoPersistentColumns">永続化されないカラム</a></h5>
	<p>カラムが永続化の対象かどうかという情報は、テーブルの定義(JDBCのメタデータ)より自動的に取得されます。また、明示的にNO_PERSISTENT_PROPSを使って永続化したくないカラムを指定することもできます。NO_PERSISTENT_PROPSに空文字を指定するとJDBCのメタデータのメタデータを使わずにすべてのプロパティを永続化の対象とみなします。</p>
<pre>
public static final String NO_PERSISTENT_PROPS = "dummy1, dummy2";
</pre>

<h5><a name="VersionNoPropertyAnnotation">VERSION_NO_PROPERTYアノテーション</a></h5>
<p><a href="#VersionNo">versionNo</a>による排他制御用のプロパティ名をデフォルトのversionNoから変えるときに使うのがVERSION_NO_PROPERTYアノテーションです。次のように使います。</p>
<pre>public static final String VERSION_NO_PROPERTY = "myVersionNo";</pre>

<h5><a name="TimestampPropertyAnnotation">TIMESTAMP_PROPERTYアノテーション</a></h5>
<p><a href="#Timestamp">timestamp</a>による排他制御用のプロパティ名をデフォルトのtimestampから変えるときに使うのがTIMESTAMP_PROPERTYアノテーションです。次のように使います。</p>
<pre>public static final String TIMESTAMP_PROPERTY = "myTimestamp";</pre>

	<h5><a name="property">カラムに対応するプロパティの宣言</a></h5>
     	<p>テーブルのカラムに対応した変数を宣言します。</p>
     	NUMBER型のEMPNOというカラムの場合、以下のように宣言することができます。（関連：<a href="#ColumnAnnotation">COLUMNアノテーション</a>）
<pre>private long empno;</pre>
	     <p>※カラムがNull可の場合、プリミティブ型を指定するとNullの際、0(ゼロ)が返されるのでNullを扱う場合は、
	     ラッパークラス(intならjava.lang.Integer)を指定して下さい。</p>
     <h5><a name="GetterSetterMethod">getter/setterメソッド</a></h5>
    	<p>テーブルのカラムに対応した各プロパティのgetter/setterメソッドを実装します。メソッドの命名規則は以下の形式になります。</p>
		getterメソッド
		<p>-  public <span class="italic">型</span> get<span class="italic">プロパティ名</span>()</p>
		setterメソッド
		<p>-  public void set<span class="italic">プロパティ名(引数)</span></p>
		private long empnoというプロパティの場合は以下のようになります。

<pre>private long empno;

public long getEmpno() {
    return empno;
}

public void setEmpno(long empno) {
    this.empno = empno;
}
</pre>
		<p>以上の設定を行ったEMPテーブルに関連付くJavaBeansは次のようになります。</p>
<pre>
import java.io.Serializable;

public class Employee implements Serializable {
    public static final String TABLE = "EMP";

    public static final int department_RELNO = 0;

    public static final String department_RELKEYS = "DEPTNUM:DEPTNO";

    private long empno;

    private String ename;

    private Short deptnum;

    private Department department;

    public Employee() {
    }

    public Department getDepartment() {
        return department;
    }

    public void setDepartment(Department department) {
        this.department = department;
    }

    public Short getDeptnum() {
        return deptnum;
    }

    public void setDeptnum(Short deptnum) {
        this.deptnum = deptnum;
    }

    public long getEmpno() {
        return empno;
    }

    public void setEmpno(long empno) {
        this.empno = empno;
    }

    public String getEname() {
        return ename;
    }

    public void setEname(String ename) {
        this.ename = ename;
    }
}
</pre>

    <h4><a name="Dao">Dao(Data Access Object)</a></h4>
	    <p>Daoはインターフェースとして作成します。永続化されるデータとロジックを分離して、Dao本来の目的であるBeanの永続化を行います。
	    JavaBeansとは1：1の関係にあるので、一つのJavaBeansに対して一つのDaoを作成することになります。
		Daoのメソッドを呼ぶことにより、メソッドに対応したSQLファイルに記述されているSQLが実行されます。
		Daoを作成するには、以下の点が必要になります。</p>
		<ul>
			<li>JavaBeansとの関連付けの定数宣言(<a href="#BeanAnnotation">BEANアノテーション</a>)</li>
			<li><a href="#DefMethod">メソッドの定義</a></li>
		</ul>
		<p>またメソッドの引数をSQL文で参照したり、WHERE句、ORDER句を追加、更新のSQLに含めない、あるいは含めるプロパティを指定する場合には、以下のアノテーションを使います。</p>
		<ul>
			<li><a href="#ArgsAnnotation">ARGSアノテーション</a></li>
			<li><a href="#QueryAnnotation">QUERYアノテーション</a></li>
			<li><a href="#NoPersistentPropsAnnotation">NO_PERSISTENT_PROPSアノテーション</a></li>
			<li><a href="#PersistentPropsAnnotation">PERSISTENT_PROPSアノテーション</a></li>
			<li><a href="#SqlAnnotation">SQLアノテーション</a></li>
		</ul>

    <h5><a name="BeanAnnotation">BEANアノテーション</a></h5>
	    <p>DaoがどのJavaBeans(エンティティ)に関連付けられているのかはBEANアノテーションで指定します。<br />
		BEANアノテーションは以下の形式で定数を宣言します。</p>
		<p>-  public static final Class BEAN = <span class="italic">JavaBeans名</span>.class;</p>
		<p>EmployeeDaoクラスがEmployeeエンティティに関連付けられる場合は次のように定義します。 	</p>
		<pre>public static final Class BEAN = Employee.class;</pre>
    <h5><a name="ArgsAnnotation">ARGSアノテーション</a></h5>
    	<p>メソッドの引数をSQL文で参照できるように、ARGSアノテーションを使用し、メソッドの引数名を指定します。メソッドの引数名は、リフレクションで取得できないためです。<br />
		ARGSアノテーションは以下の形式で定数を宣言します。</p>
 		<p>- public static final String <span class="italic">メソッド名</span>_ARGS = "<span class="italic">引数名</span>";</p>
 		 <p>public Employee getEmployee(int empno)というメソッドがDaoに定義されていた場合の引数名は次のように定義します。</p>
		<pre>public static final String getEmployee_ARGS = "empno";</pre>
		<p>メソッドの引数がテーブルのカラム名に対応している場合、<span class="italic">引数名</span>にはテーブルのカラム名を指定します。例えば、メソッドの引数名がempnoで、テーブルのカラム名がemployeenoの場合は、employeenoを指定するということです。
		引数が複数ある場合には、カンマで区切ります。引数が1つの場合、ARGSアノテーションは省略できます。</p>
    <h5><a name="QueryAnnotation">QUERYアノテーション</a></h5>
	    <p>自動的に生成されるSELECT文にWHERE句やORDER BY句を追加するには、QUERYアノテーションを使用します。<br />
		QUERYアノテーションは以下の形式で定数を宣言します。</p>
		<p>-  public static final String <span class="italic">メソッド名</span>_QUERY = "<span class="italic">WHERE句ORDER BY句</span>";</p>
		<p>引数で給与の上限と下限を指定し、その間に含まれる従業員を抽出する場合、次のようにします。</p>
<pre>
public static final String getEmployeesBySal_QUERY = "sal BETWEEN ? AND ? ORDER BY empno";

public List getEmployeesBySal(Float minSal, Float maxSal);
</pre>
		<p>上記例の“?”をバインド変数と言います。バインド変数をQUERYアノテーションに記述することにより、メソッドの引数の値が順に”?”の部分に代入されます。
		ARGSアノテーションは、必要ありません。ORDER BY句だけを記述するときは、ORDER BYで始めてください。<a href="#SQLbind">SQLコメント</a>も記述することが出来ます。
		SQLコメントを使用したサンプルは以下のとおりです。
		</p>
<pre>public static final String getEmployees_QUERY =
                      "job = /*job*/'CLERK'/*IF deptno != null*/ AND deptno = /*deptno*/20/*END*/";
</pre>
        <p>上記サンプルは、引数deptnoがnullでない場合、deptnoが引数の値と一致するという条件を追加します。SQLコメントについての詳しい説明は、<a href="#SQLbind">SQLコメント</a>の項目を参照して下さい。</p>

	<h5><a name="DefMethod">メソッドの定義</a></h5>
	    <p>Daoに定義したメソッドを呼ぶことにより、対応するSQLファイルに記述されているSQLが実行されますが、
		更新(INSERT, UPDATE, DELETE)、検索処理ごとにメソッドの命名規則があります。S2Daoではメソッドの命名規則よりSQL文の中身を自動的に決定しています。
		また、定義するメソッドのオーバーロードはサポートしていません。
		</p>
		<ul>
		<li>INSERT処理</li>
		<p>INSERT処理を行なうメソッドの名前が、insert,add,createではじまる必要があります。
		ただし、v1.0.32からdao.diconファイルの設定により変更することができます。<a href="#diconfile">diconファイル</a>をご覧ください。<br />
		戻り値はvoidあるいはintを指定してください。
		intの場合、更新した行数が戻り値となります。引数の型はエンティティの型と一致させます。<br />
		メソッドの定義例は以下のようになります。</p>
<pre>public void insert(Department department);
public int addDept(Department department);
public void createDept(Department department);
</pre>
		<li>UPDATE処理</li>
		<p>UPDATE処理を行うメソッドの名前が、update,modify,storeではじまる必要があります。
		ただし、v1.0.32からdao.diconファイルの設定により変更することができます。<a href="#diconfile">diconファイル</a>をご覧ください。<br />
		戻り値はvoidあるいはintです。intの場合、更新した行数が戻り値となります。引数の型はエンティティの型と一致させます。<br />
メソッドの定義例は以下のようになります。</p>
<pre>
public int update(Department department);
public int modifyDept(Department department);
public void storeDept(Department department);
</pre>
		<p>v1.0.37からはメソッド名の末尾に<b>UnlessNull</b>が付いているUPDATE処理の場合、引数に渡されたDTOのフィールドの内、nullでは無い値のみを更新対象とします(<a href="#batch">バッチ処理</a>の場合はこの機能は使えません)。<br　/>
		<b>UnlessNull</b>は、dao.diconファイルの設定により変更することができます。<a href="#diconfile">diconファイル</a>をご覧ください。<br />
		メソッドの定義例は以下のようになります。
<pre>
public int updateUnlessNull(Department department);
</pre>
		</p>
		<p>v1.0.40からはメソッド名の末尾に<b>ModifiedOnly</b>が付いているUPDATE処理の場合、getModifiedPropertyNamesメソッドを実装するDTOを引数に渡すと、フィールドの内、更新された(setterが呼ばれて変更された)値のみを更新対象とします(<a href="#batch">バッチ処理</a>の場合はこの機能は使えません)。<br />
		getModifiedPropertyNamesメソッドを実装する方法は、以下の二通りがあります。<br/>
		<ul>
			<li>dao.diconでBeanEnhancerImplを指定して、Daoの検索メソッドからDTOを取得する(S2Daoがメソッドを埋め込みます)</li>
			<li>DTOにgetModifiedPropertyNamemメソッドを直に実装する<br/>
				この場合、DTOの定義例は以下のようになります。
				<pre>
public class Emp {

    public static final String TABLE = "EMP";

    private long empno;

	(略)

    private java.util.Set _modifiedPropertySet = new java.util.HashSet();

    public long getEmpno() {
        return this.empno;
    }

    public void setEmpno(long empno) {
        _modifiedPropertySet.add("empno");
        this.empno = empno;
    }

(略)
    public java.util.Set getModifiedPropertyNames() {
        return _modifiedPropertySet;
    }
}
				</pre>
		</ul>
		<b>ModifiedOnly</b>は、dao.diconファイルの設定により変更することができます。<a href="#diconfile">diconファイル</a>をご覧ください。<br　/>
		メソッドの定義例は以下のようになります。
<pre>
public int updateModifiedOnly(Department department);
</pre>
		</p>
		<li>DELETE処理</li>
		<p>DELETE処理を行うメソッドの名前が、delete,removeではじまる必要があります。
		ただし、v1.0.32からdao.diconファイルの設定により変更することができます。<a href="#diconfile">diconファイル</a>をご覧ください。<br />
		戻り値はvoidあるいはintです。
		intの場合、更新した行数が戻り値となります。引数の型はエンティティの型と一致させます。<br />
		メソッドの定義例は以下のようになります。</p>
<pre>
public void delete(Department department);
public int removeDept(Department department);
</pre>
		<li>検索(SELECT)処理</li>
		<p>検索処理を行ないたい場合は、戻り値の型を指定します。戻り値の型がjava.util.Listを実装している場合、SELECT文でエンティティのリストを返します。
		戻り値がエンティティ型の配列である場合、エンティティ配列を返します。戻り値の型がエンティティの型の場合、エンティティを返します。
		それ以外の場合、SELECT count(*) FROM empのように1行で1のカラムの値を返すというようにS2Daoは想定します。</p>
		</ul>

	<h5><a name="NoPersistentPropsAnnotation">NO_PERSISTENT_PROPSアノテーション</a></h5>
	<p>更新するときに、このプロパティは、SQLに含めて欲しくないという場合もあります。
	そのような場合は、NO_PERSISTENT_PROPSアノテーションを使います。</p>
	<pre>public static final String insert_NO_PERSISTENT_PROPS = "sal, comm";</pre>
	<p>上記のように指定すると、insertメソッドで、salとcommプロパティは永続化の対象になりません。</p>

	<h5><a name="PersistentPropsAnnotation">PERSISTENT_PROPSアノテーション</a></h5>
	<p>更新するときに、このプロパティだけをSQLに含めたいという場合もあります。
	そのような場合は、PERSISTENT_PROPSアノテーションを使います。</p>
	<pre>public static final String insert_PERSISTENT_PROPS = "deptno";</pre>
	<p>上記のように指定すると、insertメソッドで、プライマリーキー、versionNo、timestampのプロパティに加えて、
	PERSISTENT_PROPSアノテーションで指定したプロパティが永続化の対象になります。</p>
 	<h5><a name="SqlAnnotation">SQLアノテーション</a></h5>
	<p>バージョン1.0.28より、SQLアノテーションを使用することが可能です。機能はSQLファイルと同様で、アノテーションにてSQL及びSQLコメントを使用することが可能です。</p>
 	<p>SQLアノテーションに命名規則があります。</p>
 	<ul>
 	<li>SQLファイルとDaoに定義したメソッドの関連付け</li>
 	<p>SQLアノテーションとDaoに定義したメソッドの関連付けをするには、SQLアノテーションを以下の形式にする必要があります。</p>
 	<p>-  <span class="italic">メソッド名</span>_SQL</p>
 	examples.dao.EmployeeDao#getAllEmployees()に対応するSQLアノテーションは以下のようになります。
 	<pre>public static final String getAllEmployees_SQL = "SELECT
emp.*, dept.dname dname_0, dept.loc loc_0 FROM emp, dept
 WHERE emp.deptno = dept.deptno ORDER BY emp.empno;";</pre>
 	<li>複数DBMS対応</li>
 	<p>DBMSごとに使用するSQLアノテーションを指定することができます。
 	どのDBMSを使っているのかはjava.sql.DatabaseMetadata#getDatabaseProductName()に応じて、S2Daoが自動的に判断しています。
 	S2DaoのほうでDBMSごとにサフィックスを決めているので、SQLアノテーションにサフィックスを追加します。
 	例えばオラクルの場合、サフィックスはoracleなので、「getAllEmployees_oracle_SQL」というSQLアノテーションになります。</p>
 	DBMSとサフィックスの関係は以下の通りです。
		<table border="1" class="main">
			<tr bgcolor="#d1f3f4" align="center">
				<th scope="col">DBMS</th>
				<th scope="col">サフィックス</th>
			</tr>
			<tr>
				<td>Oracle</td>
				<td>oracle</td>
			</tr>
			<tr>
				<td>DB2</td>
				<td>db2</td>
			</tr>
			<tr>
				<td>MSSQLServer</td>
				<td>mssql</td>
			</tr>
			<tr>
				<td>MySQL</td>
				<td>mysql</td>
			</tr>
			<tr>
				<td>PostgreSQL</td>
				<td>postgre</td>
			</tr>
			<tr>
				<td>Firebird</td>
				<td>firebird</td>
			</tr>
			<tr>
				<td>MaxDB</td>
				<td>maxdb</td>
			</tr>
			<tr>
				<td>HSQL</td>
				<td>hsql</td>
			</tr>
			<tr>
				<td>Derby</td>
				<td>derby</td>
			</tr>
			<tr>
				<td>H2</td>
				<td>h2</td>
			</tr>

 		</table>
 	</ul>
 	<h5><a name="ProcedureAnnotation">PROCEDUREアノテーション</a></h5>
	<p>バージョン1.0.31より、PROCEDUREアノテーションを使用することによりStoredProcedureやStoredFunctionを実行することができます。PROCEDUREアノテーションは以下の形式のうちいずれかを指定します。</p>
	<p>-  public static final String <span class="italic">メソッド名</span>_PROCEDURE = "<span class="italic">カタログ名.スキーマ名.プロシジャ名</span>";</p>
	<p>-  public static final String <span class="italic">メソッド名</span>_PROCEDURE = "<span class="italic">スキーマ名.プロシジャ名</span>";</p>
	<p>-  public static final String <span class="italic">メソッド名</span>_PROCEDURE = "<span class="italic">プロシジャ名</span>";</p>
	<p>-  public static final String <span class="italic">メソッド名</span>_PROCEDURE = "<span class="italic">パッケージ名.プロシージャ名</span>";(Oracle/1.0.41以降)</p>
	<p>-  public static final String <span class="italic">メソッド名</span>_PROCEDURE = "<span class="italic">スキーマ名.パッケージ名.プロシージャ名</span>";(Oracle/1.0.41以降)</p>

 	<ul>
 	<li>サポートされるStoredProcedureの範囲について</li>
 	<p>PROCEDUREアノテーションでは、
 	<ul>
 		<li>戻り値のあるStoredProcedure</li>
 		<li>IN,OUT,INOUTパラメータを複数持つStoredProcedure</li>
 		<li>ResultSetを返すStoredProcedure</li>
 	</ul>
 	をサポートしています。
 	ただし、OUTやINOUTパラメータが複数ある場合はメソッドの返り値がMapでなければなりません。
 	<p>また、DBMSやJDBCドライバの実装によっては、利用できない場合があります。</p>
 	<table class="main" border="1">
 		<tbody><tr align="center" bgcolor="#d1f3f4">
 			<th scope="col">DBMS</th>
 			<th scope="col">制限事項</th>
 		</tr>
 		<tr>
 			<td>Oracle</td>
 			<td>すべてのパターンが利用できます。</td>
 		</tr>
 		<tr>
 			<td>DB2</td>
 			<td>-</td>
 		</tr>
 		<tr>
 			<td>MSSQLServer</td>
 			<td>-</td>
 		</tr>
 		<tr>
 			<td>MySQL</td>
 			<td>StoredFunctionがサポートされていません</td>
 		</tr>
 		<tr>
 			<td>PostgreSQL</td>
 			<td>2つ以上のOUTやINOUTパラメータを持つStoredFunctionがサポートされていません</td>
 		</tr>
 		<tr>
 			<td>Firebird</td>
 			<td>-</td>
 		</tr>
 		<tr>
 			<td>HSQLDB</td>
 			<td>サポートされていません</td>
 		</tr>
 		<tr>
 			<td>Derby</td>
 			<td>StoredFunctionがサポートされていません</td>
 		</tr>
 	</tbody></table>
 	</ul>

    <h4><a name="diconfile">diconファイル</a></h4>
    	<p>diconファイルはDaoをコンテナにコンポーネント登録します。Dao機能を使用するには、登録したDaoに対して、AOPを適用する必要があります。
    	diconファイルはどこに配置してもいいのですが、通常Daoと同じ場所に配置します。なお、1.0.36以降はjarファイル内にdao.diconが含まれているため、デフォルトで使用する場合はdao.diconを配置する必要はないです。
    	diconファイルの詳しい設定方法については、<a href="http://s2container.seasar.org/ja/DIContainer.html">DIContainer</a>を参照して下さい。</p>
		<h5>S2DaoInterceptorの適用</h5>
    	<p>Dao機能を使用するにはorg.seasar.dao.interceptors.S2DaoInterceptorを登録したDaoに対してAOPを適用します。<br />
    	AOPについては、<a href="http://s2container.seasar.org/ja/aop.html">AOP</a>のページを参照して下さい。<br />
    	以下はDao(example.dao.EmployeeDao)をコンポーネント登録するサンプル</p>
    	EmployeeDao.dicon
<pre>
&lt;components&gt;
    &lt;include path="dao.dicon"/&gt;
    &lt;component class="example.dao.EmployeeDao"&gt;
        &lt;aspect&gt;dao.interceptor&lt;/aspect&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>
        dao.dicon
<pre>
&lt;components namespace="dao"&gt;
    &lt;include path="j2ee.dicon"/&gt;
    [...]
    &lt;component
        class="org.seasar.dao.impl.DaoMetaDataFactoryImpl"/&gt;
    &lt;component name="interceptor"
        class="org.seasar.dao.interceptors.S2DaoInterceptor"/&gt;
    [...]
&lt;/components&gt;
</pre>
		<p>&lt;component class="org.seasar.dao.impl.DaoMetaDataFactoryImpl"/&gt;はS2DaoInterceptorのコンストラクタの引数となるので、
		org.seasar.dao.impl.DaoMetaDataFactoryImplも記述しておきます。
		(<a href="#dao.dicon">セットアップの項</a>も参照)</p>
		<p>v1.0.32以降のバージョンは、DaoMetaDataFactoryImplに対して以下のプロパティを設定することができます。</p>
			<dt>sqlFileEncoding</dt>
				<dd>String</dd>
				<dd>Sqlファイルのエンコーディングを指定します。デフォルトは"JISAutoDetect"です。</dd>
		</p>
		<p>v1.0.32からv1.0.39までのバージョンは、DaoMetaDataFactoryImplに対して以下のプロパティを設定することができます。</p>
		<dl>
			<dt>daoSuffixes</dt>
				<dd>String[]</dd>
				<dd>Daoインターフェース名の最後に付いていなければならない名前を指定します。デフォルトは{"Dao"}です。</dd>
			<dt>insertPrefixes</dt>
				<dd>String[]</dd>
				<dd>insertメソッドの最初に付いていなければならない名前を指定します。デフォルトは{ "insert","create", "add" }です。</dd>
			<dt>updatePrefixes</dt>
				<dd>String[]</dd>
				<dd>updateメソッドの最初に付いていなければならない名前を指定します。デフォルトは{ "update","modify", "store" }です。</dd>
			<dt>deletePrefixes</dt>
				<dd>String[]</dd>
				<dd>deleteメソッドの最初に付いていなければならない名前を指定します。デフォルトは{ "delete","remove" }です。</dd>
		</dl>
		<p>v1.0.37からv1.0.39までのバージョンは、DaoMetaDataFactoryImplに対して以下のプロパティを設定することができます。</p>
		<dl>
			<dt>unlessNullSuffixes</dt>
				<dd>String[]</dd>
				<dd>引数に渡されたDTOのフィールドの内、nullでは無い値のみを更新対象にする場合、メソッドの最後に付いていなければならない名前を指定します。<br　/>
				メソッド名デフォルトは{"UnlessNull"}です。</dd>
		</dl>
		<p>v1.0.40以降のバージョンは、DaoNamingConventionImplに対して以下のプロパティを設定することができます。
		<dl>
			<dt>daoSuffixes</dt>
				<dd>String[]</dd>
				<dd>Daoインターフェース名の最後に付いていなければならない名前を指定します。デフォルトは{"Dao"}です。</dd>
			<dt>insertPrefixes</dt>
				<dd>String[]</dd>
				<dd>insertメソッドの最初に付いていなければならない名前を指定します。デフォルトは{ "insert","create", "add" }です。</dd>
			<dt>updatePrefixes</dt>
				<dd>String[]</dd>
				<dd>updateメソッドの最初に付いていなければならない名前を指定します。デフォルトは{ "update","modify", "store" }です。</dd>
			<dt>deletePrefixes</dt>
				<dd>String[]</dd>
				<dd>deleteメソッドの最初に付いていなければならない名前を指定します。デフォルトは{ "delete","remove" }です。</dd>
			<dt>unlessNullSuffixes</dt>
				<dd>String[]</dd>
				<dd>引数に渡されたDTOのフィールドの内、nullでは無い値のみを更新対象にする場合、メソッドの最後に付いていなければならない名前を指定します。<br　/>
				メソッド名デフォルトは{"UnlessNull"}です。</dd>
			<dt>modifiedOnlySuffixes</dt>
				<dd>String[]</dd>
				<dd>引数に渡されたDTOのフィールドの内、更新された値のみを更新対象にする場合、メソッドの最後に付いていなければならない名前を指定します。<br　/>
				メソッド名デフォルトは{"ModifiedOnly"}です。</dd>
			<dt>modifiedPropertyNamesPropertyName</dt>
				<dd>String</dd>
				<dd>更新された値のみを更新対象にする場合、DTOが持つべきプロパティ名を指定します。<br　/>
				プロパティ名デフォルトは{"modifiedPropertyNames"}です。</dd>
		</dl>

		</p>
		
    <h4><a name="SQLfile">SQLファイル</a></h4>
    	<p>検索、更新処理等を行うSQL文を記述します。
		Daoに定義したメソッドを呼び出すと、対応するSQLファイルに記述されているSQL文が発行されます。
		作成したSQLファイルはDaoと同じ場所に配置してください。
		※S2DaoにはSQLを<a href="#AutoUpdate">自動で生成する機能</a>が用意されているので、SQLファイルがない場合、S2DaoがSQL文を自動生成します。</p>
		<h5>SQLファイル名</h5>
		<p>S2DaoにはSQLのファイル名にも命名規則があります。</p>

		<ul>
		<li>SQLファイルとDaoに定義したメソッドの関連付け</li>
		<p>作成したSQLファイルとDaoに定義したメソッドの関連付けをするには、SQLファイルのファイル名を以下の形式にする必要があります。</p>
		<p>-  <span class="italic">Daoのクラス名</span>_<span class="italic">メソッド名</span>.sql</p>
		examples.dao.EmployeeDao#getAllEmployees()に対応するSQLファイルは以下のようになります。
		<pre>examples/dao/EmployeeDao_getAllEmployees.sql	</pre>
		<li>複数DBMS対応</li>
		<p>DBMSごとに使用するSQLファイルを指定することができます。
		どのDBMSを使っているのかはjava.sql.DatabaseMetadata#getDatabaseProductName()に応じて、S2Daoが自動的に判断しています。
		S2DaoのほうでDBMSごとにサフィックスを決めているので、SQLファイル名にサフィックスを追加します。
		例えばオラクルの場合、サフィックスはoracleなので、「EmployeeDao_getAllEmployees_oracle.sql」というファイル名になります。</p>
		DBMSとサフィックスの関係は以下の通りです。
		<table border="1" class="main">
			<tr bgcolor="#d1f3f4" align="center">
				<th scope="col">DBMS</th>
				<th scope="col">サフィックス</th>
			</tr>
			<tr>
				<td>Oracle</td>
				<td>oracle</td>
			</tr>
			<tr>
				<td>DB2</td>
				<td>db2</td>
			</tr>
			<tr>
				<td>MSSQLServer</td>
				<td>mssql</td>
			</tr>
			<tr>
				<td>MySQL</td>
				<td>mysql</td>
			</tr>
			<tr>
				<td>PostgreSQL</td>
				<td>postgre</td>
			</tr>
			<tr>
				<td>Firebird</td>
				<td>firebird</td>
			</tr>
			<tr>
				<td>MaxDB</td>
				<td>maxdb</td>
			</tr>
			<tr>
				<td>HSQL</td>
				<td>hsql</td>
			</tr>
			<tr>
				<td>Derby</td>
				<td>derby</td>
			</tr>
			<tr>
				<td>H2</td>
				<td>h2</td>
			</tr>
		</table>
		</ul>
		<h5>SQL文の記述</h5>
		<p>SQLファイルには、”SELECT * FROM EMP”, “DELETE FROM EMP WHERE EMPNO = 7788”といった、普通のSQL文を記述することが可能です。
		また、WHERE句の条件の値などを動的に変化させることも可能です。詳しくは、<a href="#SQLbind">SQLコメント</a>を参照して下さい。</p>

	<h3><a name="SQLBind">SQLコメント</a></h3>
		<p>S2Daoでは、メソッドの引数とSQL文のバインド変数の対応付けを/**/や--などのコメントを使って行います。
		コメントなので、対応付けをした後でも、SQL*PlusなどのSQLのツールでそのまま実行することができます。
		最初、SQLのツールでSQL文を実行して思い通りの結果を出力するようになったら、
		それに対して、コメントを埋め込んでいくと良いでしょう。</p>
		<p>また、SQL文に対しての説明の意味でのコメントを使用したい場合は、/*の後にスペースを入れることにより、
		普通のコメントを使用することが出来ます。例として、/* hoge*/となります。/*の後にスペースが入っているので、実行時には無視されます。</p>
		<h4>バインド変数コメント</h4>
		<p>Daoに定義したメソッドの引数の値をSQL文で使用する場合は、SQL文にバインド変数コメントを記述します。
		バインド変数コメントの右側のリテラルに引数の値が自動的に置換され実行されます。
		バインド変数コメントは、以下のように記述します。</p>
		<p> -  /*<span class="italic">引数名</span>*/<span class="italic">リテラル</span></p>
		<p>引数がJavaBeansの場合は以下のように記述します。</p>
		<p>-  /*<span class="italic">引数名</span>.<span class="italic">プロパティ名</span>*/<span class="italic">リテラル</span></P>
		<p>引数名はDaoに設定したARGSアノテーションの値と揃える必要があります。
		(ただし引数が一つの場合は、その制約はありません。)</p>
<pre>
public String getEmployee_ARGS = "empno";

public Employee getEmployee(int empno);
</pre>
		<p>Daoに上記のメソッドを定義した場合、SQLファイル(EmploeeDao_getEmployee.sql)は次のようにバインド変数を使用することが可能です。自動的にgetEmployeeメソッドの引数の値が設定されます。</p>
		<pre>SELECT * FROM emp WHERE empno = /*empno*/7788</pre>
		<p>IN句にバインド変数を適用したい場合は以下のようにすることができます。</p>
		<p>-  IN /*<span class="italic">引数名</span>*/(...)</p>
		<pre>IN /*names*/('aaa', 'bbb')</pre>
		<p>引数はjava.util.Listや配列の引数となります。上記のIN句の場合は、以下のように引数を用意します。</p>
		<pre>String[] names = new String[]{"SCOTT", "SMITH", "JAMES"};</pre>
 		<p>String配列namesが自動的にバインド変数の部分に置換されます。</p>
		<p>LIKEを使用する場合は、次のようにします。</p>
		<pre>ename LIKE /*ename*/'hoge'</pre>
		<p>ワイルドカードを使いたい場合は、メソッドの引数の値に埋め込みます。
		「"COT"を含む」という条件を指定する場合は、以下のように引数の値にワイルドカードを埋め込みます。</p>
		<pre>employeeDao.findEmployees("%COT%");</pre>

		<h4>埋め込み変数コメント</h4>
		<p>Daoに定義したメソッドの引数の値をSQL文に文字列として直接埋め込む場合は、SQL文に埋め込み変数コメントを記述します。
		埋め込み変数コメントの右側のリテラルに引数の値が自動的に置換され実行されます。
		埋め込み変数コメントは、以下のように記述します。</p>
		<p> -  /*<span class="italic">$引数名</span>*/<span class="italic">リテラル</span></p>
		<p>引数がJavaBeansの場合は以下のように記述します。</p>
		<p>-  /*<span class="italic">$引数名</span>.<span class="italic">プロパティ名</span>*/<span class="italic">リテラル</span></P>
		<p>埋め込み変数コメントを使用する場合、SQLインジェクションに対する対策はDaoの呼び出し側で行う必要があります。</p>

		<h4>IFコメント</h4>
		<p>IFコメントでは、条件に応じて実行するSQL文を変えることが可能です。IFコメントは以下の形式で記述します。</p>
		<p> -  /*IF <span class="italic">条件</span>*/ .../*END*/</p>
		<p>サンプルは以下のとおりです。</p>
<pre>/*IF hoge != null*/hoge = /*hoge*/'abc'/*END*/</pre>
		<p>IFコメントは、条件が真の場合、/*IF*/と/*END*/に囲まれた部分が評価されます。
		上記の場合、引数hogeがnull出ない場合にのみ、IFコメントで囲まれている部分(hoge = /*hoge*/'abc')が評価されます。
		<br />また偽の場合の処理としてELSEコメントというものが用意されています。
		条件が偽となった場合は、”ELSE”の後に記述した部分が評価されます。ELSEコメントは以下のように記述します。</p>

<pre>
/*IF hoge != null*/hoge = /*hoge*/'abc'
  -- ELSE hoge is null
/*END*/
</pre>
		<p>条件がfalseになると-- ELSEの後の部分(hoge is null)が評価されます。</p>
		<h4>BEGINコメント</h4>
		<p>BEGINコメントは、WHERE句内のすべてのELSEを含まないIFコメントがfalseになった場合に、
		WHERE句自体を出力したくない場合に使います。BEGINコメントはIFコメントと併せて使用します。<br />
		BEGINコメントは以下の形式で記述します。</p>
		<p>-   /*BEGIN*/<span class="italic">WHERE句</span>/*END*/</p>
		サンプルは以下の通りです。
<pre>
/*BEGIN*/WHERE
  /*IF job != null*/job = /*job*/'CLERK'/*END*/
  /*IF deptno != null*/AND deptno = /*deptno*/20/*END*/
/*END*/
</pre>
		<p>上記の場合、job,deptnoがnullの場合は、WHERE句は出力されません。
		job == null,deptno != nullの場合は、WHERE depno = ?、 job != null,deptno == nullの場合は、WHERE job = ?、
		job != null,deptno != nullの場合は、WHERE job = ? AND depno = ?のようになります。動的SQLも思いのままです。</p>

	<h3><a name="EntityManager">EntityManagerを使用したQueryの実行</a></h3>
		<p>EntityManagerを使用し、自動的に生成されるSELECT文にWHERE句やORDER BY句を追加できます。書き方は、<a href="#QueryAnnotation">QUERYアノテーション</a>と同様です。
		主に、動的にQueryを組み立てたいときに使用します。EntityManagerを使用するには、以下のクラスを継承します。</p>
		<p>- org.seasar.dao.impl.AbstractDao</p>
		<p>Daoのインターフェース名は、必ず"Dao"で終わるようにしてください。S2Daoは、AbstractDaoを継承したクラスが実装しているインターフェースの中で、
		クラス名が"Dao"で終わっているインターフェースをDaoインターフェースだと判断しているためです。</p>
		EntityManagerには、以下のメソッドが用意されています。
		<dl>
			<dt style="text-indent:1em;">find()メソッド</dt>
			<dd>戻り値をjava.util.Listで返します。引数の種類は以下の通りです。<br />
			public List find(String query);<br />
			public List find(String query, Object arg1);<br />
			public List find(String query, Object arg1, Object arg2);<br />
			public List find(String query, Object arg1, Object arg2, Object arg3);<br />
			public List find(String query, Object[] args);<br /><br />
			</dd>
			<dt style="text-indent:1em;">findArray()メソッド</dt>
			<dd>戻り値を配列で返します。引数の種類は以下の通りです。<br />
			public Object[] findArray(String query);<br />
			public Object[] findArray(String query, Object arg1);<br />
			public Object[] findArray(String query, Object arg1, Object arg2);<br />
			public Object[] findArray(String query, Object arg1, Object arg2, Object arg3);<br />
			public Object[] findArray(String query, Object[] args);<br /><br />
			</dd>
			<dt style="text-indent:1em;">findBean()メソッド</dt>
			<dd>戻り値をJavaBeansで返します。引数の種類は以下の通りです。<br />
			public Object findBean(String query);<br />
			public Object findBean(String query, Object arg1);<br />
			public Object findBean(String query, Object arg1, Object arg2);<br />
			public Object findBean(String query, Object arg1, Object arg2, Object arg3);<br />
			public Object findBean(String query, Object[] args);<br /><br />
			</dd>
			<dt style="text-indent:1em;">findObject()メソッド</dt>
			<dd>戻り値をcount(*)の結果のような単独の値を返します。引数の種類は以下の通りです。<br />
			public Object findObject(String query);<br />
			public Object findObject(String query, Object arg1);<br />
			public Object findObject(String query, Object arg1, Object arg2);<br />
			public Object findObject(String query, Object arg1, Object arg2, Object arg3);<br />
			public Object findObject(String query, Object[] args);
			</dd>
		</dl>
		引数は、QUERYアノテーションと同様に記述します。Object型の引数が4つ以上になるの場合は、Object型の配列を使用します。
		<h4>AbstractDaoを継承したクラスの基本的な実装方法</h4>
		<ol>
			<li>org.seasar.dao.impl.AbstractDaoの継承</li>
			<li>Daoをimplementsする</li>
			<br />implementsするDaoのインターフェース名の最後は"Dao"で終了している必要があります。
			<li>コンストラクタの実装</li>
			<br />org.seasar.dao.DaoMetaDataFactoryを引数とし、super(org.seasar.dao.DaoMetaDataFactory)を呼び出します。
			<li>Daoに定義したメソッドの実装</li>
			<br />EntityManagerで提供しているメソッドを使用する場合は、getEntityManager().find(...);のように、getEntityManager()メソッドを使用し、EntityManagerを取得し呼び出すことが出来ます。
			<br />
		</ol>
		AbstractDaoを継承したクラスのサンプルは以下の通りです。
<pre>
package examples.dao;

import java.util.List;

import org.seasar.dao.DaoMetaDataFactory;
import org.seasar.dao.impl.AbstractDao;

public class Employee2DaoImpl extends AbstractDao implements Employee2Dao {

    public Employee2DaoImpl(DaoMetaDataFactory daoMetaDataFactory) {
        super(daoMetaDataFactory);
    }

    public List getEmployees(String ename) {
        return getEntityManager().find("ename LIKE ?", "%" + ename + "%");
    }
}
</pre>
	<p>詳しい使用方法は<a href="#EntityManagerExample">EntityManagerを使用したExample</a>を参照して下さい。</p>

    <h3><a name="AutoUpdate">更新SQLの自動生成</a></h3>
	    <p>更新SQL文を自動生成させるには、メソッド名を<a href="#DefMethod">命名規則</a>にあわせ、JavaBeansを1つ引数に持つメソッドを定義するだけです。
	    SQLファイルの作成は不要です。例としてInsertの場合、命名規則に合わせ、以下のように定義します。</p>
<pre>
public int insert(Department department);
</pre>

    <h3><a name="VersionNo">VersionNoによる排他制御 </a></h3>
	    <p>S2Daoは排他制御も自動的に行うことができます。<br />
		設定方法は、テーブルに排他制御用のカラムを用意し、JavaBeansにint型(もしくはInteger型)でversionNoと定義するだけで、versionNoによる排他制御を自動的に行ってくれます。</p>
		<p>例えば、2人のユーザがversionNo値0の同一データを取得して更新しようとした場合、
        先に更新したユーザは正常に登録することができます。そのとき自動でversionNoはインクリメントされ、DBのversionNoは1となります。
        次にもう１人のユーザがデータを更新しようとすると、ユーザが保持しているversionNoの値(0)と、
        実際にDB格納されているversionNoの値(1)が異なることになり、NotSingleRowUpdatedRuntimeExceptionが発生し更新失敗することになります。</p>

    <h3><a name="Timestamp">Timestampによる排他制御 </a></h3>
	    <p>VersionNoの他にTimestampによる排他制御もS2Daoが自動的に行うことができます。
	    Timestamp型でtimestampという名前のプロパティを定義するだけで、自動的に行ってくれます。
	    DaoからInsertする時に、new java.sql.Timestamp()をtimestampプロパティへセットしてInsert文を発行します。
	    更新(Update・Delete)時に、JavaBeansのtimestampプロパティ値とレコードのtimestampカラム値を比較し、
	    異なっている場合にはVersionNoと同様にNotSingleRowUpdatedRuntimeExceptionが投げられます。
	    更新時にTimestamp用のカラムの値にnullが設定されていると比較に失敗するので注意してください。</p>

	<h3><a name="batch">バッチ更新</a></h3>
		<p>更新系のメソッドで次のように引数をエンティティのクラスの配列またはListにすると自動的に更新用のSQL文を生成し、バッチ更新をすることができます。なお、バッチ更新の場合、<a href="#IDAutoGenerate">IDの自動生成</a>を行うことはできません。</a></p>
		<pre>int insertBatch(Employee[] employees)</pre>

	<h3><a name="AutoSelect">検索SQLの自動生成</a></h3>
    	<p>メソッドのsignatueより、 S2Daoに自動的にSELECT文を生成させることもできます。ARGSアノテーションにカラム名を指定することで、引数の値によってWHERE句が変わるような動的なSQL文も自動生成できます。</p>
<pre>
SELECT * FROM emp
/*BEGIN*/WHERE
  /*IF job != null*/job = /*job*/'CLERK'/*END*/
  /*IF deptno != null*/AND deptno = /*deptno*/20/*END*/
/*END*/
</pre>
		<p>上記SQL文に相当するSQL文を自動生成するには以下のように定義します。上記SQLの/**/などについては、<a href="#SQLBind">SQLコメント</a>を参照してください。</p>
<pre>
public static final String getEmployeeByJobDeptno_ARGS = "job, deptno";
public List getEmployeeByJobDeptno(String job, Integer deptno);
</pre>
		<p><a href="#N1Mapping">N:1でマッピング</a>されているカラムを指定する場合には、「カラム名_関連番号」で指定します。
		N:1でマッピングされているBeanは左外部結合を使って1つのSQL文で取得されます。左外部結合をサポートしていないRDBMSはSELECT文自動生成の対象外です。
		オラクルのように左外部結合が標準と異なる場合も、S2DaoがRDBMSがオラクルであると自動的に判断して適切なSQL文を組み立てます。</p>
		<p>引数にDTO（Data Transter Object）を指定することもできます。その場合、ARGSアノテーションを指定してはいけません。
		S2Daoは、引数が1つで、ARGSアノテーションが指定されていない場合、引数をDTOとみなし、DTOのプロパティを使って自動的にSQL文を組み立てます。
		プロパティ名とカラム名が異なる場合は、COLUMNアノテーションを使ってカラム名を指定します。N:1でマッピングされているカラムを指定する場合には、カラム名_関連番号で指定します。
		テーブルに存在しないプロパティ(カラム)は自動的に無視されます。プロパティの値によって、WHERE句が変わるような動的SQL文を自動生成します。<br />
		動的SQL文の自動生成とORDER BYではじまるQUERYアノテーションは併用することが出来ます。 </p>
<pre>
package examples.dao;

public class EmployeeSearchCondition {

    public static final String dname_COLUMN = "dname_0";
    private String job;
    private String dname;
    ...
}
</pre>
<pre>List getEmployeesBySearchCondition(EmployeeSearchCondition dto);</pre>
	<p>また同様の指定方法で引数にEntityを使用することも出来ます。DTOの詳しい使用方法は、<a href="#AutoSelectExample">自動で検索用SQL文を生成する場合のExample</a>を参照して下さい。<br />
	更に、v1.0.37より、同様の指定方法で、引数にBEANアノテーションと互換性のある型を使用する事も出来ます。その場合、BEANアノテーションに定義された型がDTOとして使用されます。	
	例えば、以下の様なDao定義を行う事が出来ます。</p>
<pre>
public class Employee implements Entity {
    private long empno;
    private String ename;
    ...
}
</pre>
<pre>
public interface GenericDao {
    Object select(Entity entity);
    List selectList(Entity entity);
}
</pre>
<pre>
public interface EmployeeDao extends GenericDao {
    Class BEAN = Employee.class;
}
</pre>
    <h3><a name="HowToRun">S2Daoの実行</a></h3>
    <p>Daoを実行する基本的な方法は以下のようになります。</p>
	<ol>
	<li>作成したdiconファイルのパスを引数にS2Containerを生成</li>
	<li>生成したS2ContainerからgetComponentを呼び出し、登録したDaoを取得する	</li>
	<li>取得したDaoのメソッドを実行する</li>
	</ol>
	<p>S2Daoではトランザクション制御は行なっていません、トランザクションについては<a href="http://s2container.seasar.org/ja/tx.html">トランザクションの自動制御</a>を参照して下さい。</p>
    実行クラスサンプル
<pre>
package examples.dao;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class EmployeeDaoClient {

    private static final String PATH = "examples/dao/EmployeeDao.dicon";

    public static void main(String[] args) {

        S2Container container = S2ContainerFactory.create(PATH); /* 手順1 */
        container.init();
        try {
            EmployeeDao dao = (EmployeeDao) container.getComponent(EmployeeDao.class);/* 手順2 */
            System.out.println(dao.getAllEmployee(7788));/* 手順3 */
        } finally {
            container.destroy();
        }
    }
}
</pre>

    <h2><a name="Example">Example</a></h2>
    <p>このExampleは前提条件として以下のテーブル、JavaBeans、dao.diconを使用します。</p>
    	テーブル：EMP
		<table border="1" class="main">
			<tr bgcolor="#d1f3f4" align="center">
			  <th>カラム名</th>
			  <th>論理名</th>
			  <th>型</th>
			  <th>NotNull</th>
			  <th>主キー</th>
			</tr>
			<tr>
			  <td>EMPNO</td>
		      <td>従業員番号</td>
			  <td>NUMBER</td>
			  <td align="center">〇</td>
			  <td align="center">〇</td>
			</tr>
			<tr>
			  <td>ENAME</td>
			  <td>従業員名</td>
			  <td>VARCHAR</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>JOB</td>
			  <td>仕事</td>
			  <td>VARCHAR</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>MGR</td>
			  <td>上司</td>
			  <td>NUMBER</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>HIREDATE</td>
			  <td>雇用日</td>
			  <td>DATE</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>SAL</td>
			  <td>給料</td>
			  <td>NUMBER</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>COMM</td>
			  <td>手数料</td>
			  <td>NUMBER</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>DEPTNO</td>
			  <td>部署番号</td>
			  <td>NUMBER</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>TSTAMP</td>
			  <td>タイムスタンプ</td>
			  <td>TIMESTAMP</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
		</table>
    	<br />テーブル：DEPT
		<table border="1" class="main">
			<tr bgcolor="#d1f3f4" align="center">
			  <th>カラム名</th>
			   <th>論理名</th>
			  <th>型</th>
			  <th>NotNull</th>
			  <th>主キー</th>
			</tr>
			<tr>
			  <td>DEPTNO</td>
			  <td>部署番号</td>
			  <td>NUMBER</td>
			  <td align="center">〇</td>
			  <td align="center">〇</td>
			</tr>
			<tr>
			  <td>DNAME</td>
			  <td>部署名</td>
			  <td>VARCHAR</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>LOC</td>
			  <td>ロケーション</td>
			  <td>VARCHAR</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
			<tr>
			  <td>VERSIONNO</td>
			  <td>バージョン番号</td>
			  <td>NUMBER</td>
			  <td><br /></td>
			  <td><br /></td>
			</tr>
		</table>
    	<br />
    	<p>EMPテーブルに関連付くJavaBeansは次の通りです。</p>
<pre>
package examples.dao;

import java.io.Serializable;
import java.sql.Timestamp;

public class Employee implements Serializable {

    public static final String TABLE = "EMP";

    public static final int department_RELNO = 0;

    public static final String timestamp_COLUMN = "tstamp";

    private long empno;

    private String ename;

    private String job;

    private Short mgr;

    private java.util.Date hiredate;

    private Float sal;

    private Float comm;

    private int deptno;

    private Timestamp timestamp;

    private Department department;

    public Employee() {
    }

    public Employee(long empno) {
        this.empno = empno;
    }

    public long getEmpno() {
        return this.empno;
    }

    public void setEmpno(long empno) {
        this.empno = empno;
    }

    public java.lang.String getEname() {
        return this.ename;
    }

    public void setEname(java.lang.String ename) {
        this.ename = ename;
    }

    public java.lang.String getJob() {
        return this.job;
    }

    public void setJob(java.lang.String job) {
        this.job = job;
    }

    public Short getMgr() {
        return this.mgr;
    }

    public void setMgr(Short mgr) {
        this.mgr = mgr;
    }

    public java.util.Date getHiredate() {
        return this.hiredate;
    }

    public void setHiredate(java.util.Date hiredate) {
        this.hiredate = hiredate;
    }

    public Float getSal() {
        return this.sal;
    }

    public void setSal(Float sal) {
        this.sal = sal;
    }

    public Float getComm() {
        return this.comm;
    }

    public void setComm(Float comm) {
        this.comm = comm;
    }

    public int getDeptno() {
        return this.deptno;
    }

    public void setDeptno(int deptno) {
        this.deptno = deptno;
    }

    public Timestamp getTimestamp() {
        return this.timestamp;
    }

    public void setTimestamp(Timestamp timestamp) {
        this.timestamp = timestamp;
    }

    public Department getDepartment() {
        return this.department;
    }

    public void setDepartment(Department department) {
        this.department = department;
    }

    public boolean equals(Object other) {
        if (!(other instanceof Employee))
            return false;
        Employee castOther = (Employee) other;
        return this.getEmpno() == castOther.getEmpno();
    }

    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append(empno).append(", ");
        buf.append(ename).append(", ");
        buf.append(job).append(", ");
        buf.append(mgr).append(", ");
        buf.append(hiredate).append(", ");
        buf.append(sal).append(", ");
        buf.append(comm).append(", ");
        buf.append(deptno).append(", ");
        buf.append(timestamp).append(" {");
        buf.append(department).append("}");
        return buf.toString();
    }

    public int hashCode() {
        return (int) this.getEmpno();
    }
}
</pre>
    	<p>DEPTテーブルに関連付くJavaBeansは次の通りです。</p>
<pre>
package examples.dao;

import java.io.Serializable;

public class Department implements Serializable {

    public static final String TABLE = "DEPT";

    private int deptno;

    private String dname;

    private String loc;

    private int versionNo;

    public Department() {
    }

    public int getDeptno() {
        return this.deptno;
    }

    public void setDeptno(int deptno) {
        this.deptno = deptno;
    }

    public java.lang.String getDname() {
        return this.dname;
    }

    public void setDname(java.lang.String dname) {
        this.dname = dname;
    }

    public java.lang.String getLoc() {
        return this.loc;
    }

    public void setLoc(java.lang.String loc) {
        this.loc = loc;
    }

    public int getVersionNo() {
        return this.versionNo;
    }

    public void setVersionNo(int versionNo) {
        this.versionNo = versionNo;
    }

    public boolean equals(Object other) {
        if (!(other instanceof Department))
            return false;
        Department castOther = (Department) other;
        return this.getDeptno() == castOther.getDeptno();
    }

    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append(deptno).append(", ");
        buf.append(dname).append(", ");
        buf.append(loc).append(", ");
        buf.append(versionNo);
        return buf.toString();
    }

    public int hashCode() {
        return (int) this.getDeptno();
    }
}
</pre>
    	<p>各Exampleでincludeしているdao.diconは以下の通りです。</p>
<pre>
&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container//EN"
"http://www.seasar.org/dtd/components.dtd"&gt;
&lt;components namespace="dao"&gt;
    &lt;include path="j2ee.dicon"/&gt;
    &lt;component
        class="org.seasar.dao.impl.DaoMetaDataFactoryImpl"/&gt;
    &lt;component name="interceptor"
        class="org.seasar.dao.interceptors.S2DaoInterceptor"/&gt;
&lt;/components&gt;
</pre>
    	<h3><a name="SelectExample">SQL文を記述する場合のExample</a></h3>
    	<p>SQLファイルを作成し、Daoから記述したSQL文を実行する演習です。<br />
    	作成するファイルは以下のとおりです。</p>
    	<ul>
    		<li type="circle">Dao(EmployeeDao.java)</li>
    		<li type="circle">SQLファイル(EmployeeDao_getAllEmployees.sql, EmployeeDao_getEmployee.sql, EmployeeDao_getCount.sql, EmployeeDao_getEmployeeByJobDeptno.sql, EmployeeDao_update.sql)</li>
    		<li type="circle">diconファイル(EmployeeDao.dicon)</li>
    		<li type="circle">実行クラス(EmployeeDaoClient.java)</li>
    	</ul>
    	<h5>Daoの作成</h5>
    	<ul>
    		<li type="circle">EMPテーブルと対応するJavaBeansと関連付けをします。</li>
    		<li type="circle">メソッドを定義します。<br />
    		全件検索するメソッド(getAllEmployees()メソッド)<br />
    		従業員番号を引数として、一致する従業員を検索するメソッド(getEmployee(int empno)メソッド)<br />
    		従業員をカウントするメソッド(getCount()メソッド)
    		仕事と部署番号を引数として、一致する従業員を検索するメソッド(getEmployeeByJobDeptno(String job, Integer deptno)メソッド)<br />
    		従業員を更新するメソッド(update(Employee employee)メソッド)
    		</li>
    		<li type="circle">SQL文とメソッドの引数を関連付けするには<a href="#ArgsAnnotation">ARGSアノテーション</a>を使用します。</li>
    		<li type="circle">EMPテーブルの件数を取得するgetCount()メソッドは、１行でテーブルの件数が返ってくるので戻り値をintとします。</li>
    	</ul>

<pre>
package examples.dao;

import java.util.List;

public interface EmployeeDao {

    public Class BEAN = Employee.class;

    public List getAllEmployees();

    public String getEmployee_ARGS = "empno";

    public Employee getEmployee(int empno);

    public int getCount();

    public String getEmployeeByJobDeptno_ARGS = "job, deptno";

    public List getEmployeeByJobDeptno(String job, Integer deptno);

    public int update(Employee employee);
}
</pre>
		<h5>SQLファイルの作成</h5>
		<ul>
			<li type="circle">Daoに定義したメソッドに対応するSQLファイルをそれぞれ作成します。</li>
			<li type="circle">ファイル名は「クラス名_メソッド名.sql」とします。</li>
			<li type="circle">動的なSQLは<a href="#SQLbind">SQLコメント</a>を使用して作成します。</li>
		</ul>
    	EmployeeDao_getAllEmployees.sql
<pre>
SELECT emp.*, dept.dname dname_0, dept.loc loc_0 FROM emp, dept
WHERE emp.deptno = dept.deptno ORDER BY emp.empno
</pre>
    	EmployeeDao_getEmployee.sql
<pre>
SELECT emp.*, dept.dname dname_0, dept.loc loc_0 FROM emp, dept
WHERE empno = /*empno*/7788 AND emp.deptno = dept.deptno
</pre>
		EmployeeDao_getCount.sql
<pre>
SELECT count(*) FROM emp
</pre>
    	EmployeeDao_getEmployeeByJobDeptno.sql
<pre>
SELECT * FROM emp
/*BEGIN*/WHERE
  /*IF job != null*/job = /*job*/'CLERK'/*END*/
  /*IF deptno != null*/AND deptno = /*deptno*/20/*END*/
/*END*/
</pre>
		EmployeeDao_update.sql
<pre>
UPDATE emp SET ename = /*employee.ename*/'SCOTT'
WHERE empno = /*employee.empno*/7788
</pre>
		<h5>diconファイルの作成</h5>
		<ul>
			<li type="circle">dao.diconをincludeします。</li>
			<li type="circle">作成したDaoのコンポーネント定義します。</li>
			<li type="circle">Daoにdao.interceptor(S2DaoInterceptor)を適用します。</li>
		</ul>
<pre>
&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container//EN"
"http://www.seasar.org/dtd/components.dtd"&gt;
&lt;components&gt;
   &lt;include path="dao.dicon"/&gt;
   &lt;component class="examples.dao.EmployeeDao"&gt;
       &lt;aspect&gt;dao.interceptor&lt;/aspect&gt;
   &lt;/component&gt;
&lt;/components&gt;
</pre>
		<h5>実行ファイルの作成</h5>
		<ul>
			<li type="circle">org.seasar.framework.container.S2Container#create()メソッドの第1引数に作成したdiconファイル(EmployeeDao.dicon)のパスを指定してコンテナを作成します。</li>
			<li type="circle">org.seasar.framework.container.S2Container#getComponent()メソッドの第1引数にコンポーネントに登録したクラス名（EmployeeDao.class)を指定してコンポーネントを取得します。</li>
			<li type="circle">Daoに定義したメソッドを実行します。</li>
		</ul>
<pre>
package examples.dao;

import java.util.List;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class EmployeeDaoClient {

    private static final String PATH = "examples/dao/EmployeeDao.dicon";

    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        container.init();
        try {
            EmployeeDao dao = (EmployeeDao) container
                    .getComponent(EmployeeDao.class);
            List employees = dao.getAllEmployees();
            for (int i = 0; i < employees.size(); ++i) {
                System.out.println(employees.get(i));
            }

            Employee employee = dao.getEmployee(7788);
            System.out.println(employee);

            int count = dao.getCount();
            System.out.println("count:" + count);

            dao.getEmployeeByJobDeptno(null, null);
            dao.getEmployeeByJobDeptno("CLERK", null);
            dao.getEmployeeByJobDeptno(null, new Integer(20));
            dao.getEmployeeByJobDeptno("CLERK", new Integer(20));

            System.out.println("updatedRows:" + dao.update(employee));
        } finally {
            container.destroy();
        }

    }
}
</pre>
    	<h5>実行結果</h5>
<pre>
DEBUG 2004-10-12 11:07:01,117 [main] 物理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:01,133 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:01,914 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:07:02,742 [main] SELECT emp.*, dept.dname dname_0, dept.loc loc_0 FROM emp, dept
WHERE emp.deptno = dept.deptno ORDER BY emp.empno
DEBUG 2004-10-12 11:07:02,758 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:02,867 [main] 論理的なコネクションを閉じました
7369, SMITH, CLERK, 7902, 1980-12-17 00:00:00.0, 800.0, null, 20, 1980-12-17 00:00:00.0
{0, RESEARCH, DALLAS, 0}
7499, ALLEN, SALESMAN, 7698, 1981-02-20 00:00:00.0, 1600.0, 300.0, 30, 1980-12-17 00:00:00.0
{0, SALES, CHICAGO, 0}
7521, WARD, SALESMAN, 7698, 1981-02-22 00:00:00.0, 1250.0, 500.0, 30, 1980-12-17 00:00:00.0
{0, SALES, CHICAGO, 0}
7566, JONES, MANAGER, 7839, 1981-04-02 00:00:00.0, 2975.0, null, 20, 1980-12-17 00:00:00.0
{0, RESEARCH, DALLAS, 0}
7654, MARTIN, SALESMAN, 7698, 1981-09-28 00:00:00.0, 1250.0, 1400.0, 30, 1980-12-17 00:00:00.0
{0, SALES, CHICAGO, 0}
7698, BLAKE, MANAGER, 7839, 1981-05-01 00:00:00.0, 2850.0, null, 30, 1980-12-17 00:00:00.0
{0, SALES, CHICAGO, 0}
7782, CLARK, MANAGER, 7839, 1981-06-09 00:00:00.0, 2450.0, null, 10, 1980-12-17 00:00:00.0
{0, ACCOUNTING, NEW YORK, 0}
7788, SCOTT, ANALYST, 7566, 1982-12-09 00:00:00.0, 3000.0, null, 20, 2004-10-12 10:15:54.914
{0, RESEARCH, DALLAS, 0}
7839, KING, PRESIDENT, null, 1981-11-17 00:00:00.0, 5000.0, null, 10, 1980-12-17 00:00:00.0
{0, ACCOUNTING, NEW YORK, 0}
7844, TURNER, SALESMAN, 7698, 1981-09-08 00:00:00.0, 1500.0, 0.0, 30, 1980-12-17 00:00:00.0
{0, SALES, CHICAGO, 0}
7876, ADAMS, CLERK, 7788, 1983-01-12 00:00:00.0, 1100.0, null, 20, 1980-12-17 00:00:00.0
{0, RESEARCH, DALLAS, 0}
7900, JAMES, CLERK, 7698, 1981-12-03 00:00:00.0, 950.0, null, 30, 1980-12-17 00:00:00.0
{0, SALES, CHICAGO, 0}
7902, FORD, ANALYST, 7566, 1981-12-03 00:00:00.0, 3000.0, null, 20, 1980-12-17 00:00:00.0
{0, RESEARCH, DALLAS, 0}
7934, MILLER, CLERK, 7782, 1982-01-23 00:00:00.0, 1300.0, null, 10, 1980-12-17 00:00:00.0
{0, ACCOUNTING, NEW YORK, 0}
DEBUG 2004-10-12 11:07:02,883 [main] SELECT emp.*, dept.dname dname_0, dept.loc loc_0 FROM emp, dept
WHERE empno = 7788 AND emp.deptno = dept.deptno
DEBUG 2004-10-12 11:07:02,883 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:02,914 [main] 論理的なコネクションを閉じました
7788, SCOTT, ANALYST, 7566, 1982-12-09 00:00:00.0, 3000.0, null, 20, 2004-10-12 10:15:54.914
{0, RESEARCH, DALLAS, 0}
DEBUG 2004-10-12 11:07:02,914 [main] SELECT count(*) FROM emp
DEBUG 2004-10-12 11:07:02,914 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:02,914 [main] 論理的なコネクションを閉じました
count:14
DEBUG 2004-10-12 11:07:02,929 [main] SELECT * FROM emp

DEBUG 2004-10-12 11:07:02,929 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:02,945 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:07:02,945 [main] SELECT * FROM emp
WHERE
  job = 'CLERK'


DEBUG 2004-10-12 11:07:02,945 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:02,961 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:07:02,961 [main] SELECT * FROM emp
WHERE

  deptno = 20

DEBUG 2004-10-12 11:07:02,961 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:02,961 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:07:02,961 [main] SELECT * FROM emp
WHERE
  job = 'CLERK'
  AND deptno = 20

DEBUG 2004-10-12 11:07:02,961 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:03,008 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:07:03,023 [main] UPDATE emp SET ename = 'SCOTT'
WHERE empno = 7788
DEBUG 2004-10-12 11:07:03,023 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:07:03,023 [main] 論理的なコネクションを閉じました
updatedRows:1
DEBUG 2004-10-12 11:07:03,023 [main] 物理的なコネクションを閉じました
</pre>
		<p>"updatedRows"の値から更新された件数を確認することができます。<br />
		この演習は、s2dao/src/examples/dao以下に用意されています。</p>

    	<h3><a name="AutoUpdateExample">自動で更新用SQL文を生成する場合のExample</a></h3>
    	<p>自動で更新処理(UPDATE, INSERT, DELETE)のSQL文の生成とVersionNoによる排他制御の演習です。SQLファイルの作成は不要です。<br />
    	作成するファイルは以下のとおりです。</p>
    	<ul>
    		<li type="circle">Dao(DepartmentDao.java)</li>
    		<li type="circle">diconファイル(DepartmentDao.dicon)</li>
    		<li type="circle">実行クラス(DepartmentDaoClient.java)</li>
    	</ul>
    	<h5>Daoの作成</h5>
    	<ul>
    		<li type="circle">DEPTテーブルと対応するJavaBeansと関連付けをします。</li>
    		<li type="circle">更新処理を行うメソッドを定義します。<br />
    		部署を追加するメソッド(insert(Department department)メソッド)<br />
    		部署を更新するメソッド(update(Department department)メソッド)<br />
    		部署を削除するメソッド(delete(Department department)メソッド)
    		</li>
    	</ul>
<pre>
package examples.dao;

public interface DepartmentDao {

    public Class BEAN = Department.class;

    public void insert(Department department);

    public void update(Department department);

    public void delete(Department department);
}
</pre>
		<h5>diconファイルの作成</h5>
		<ul>
			<li type="circle">dao.diconをincludeします。</li>
			<li type="circle">作成したDaoのコンポーネント定義します。</li>
			<li type="circle">Daoにdao.interceptor(S2DaoInterceptor)を適用します。</li>
		</ul>
<pre>
&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container//EN"
"http://www.seasar.org/dtd/components.dtd"&gt;
&lt;components&gt;
  &lt;include path="dao.dicon"/&gt;
  &lt;component class="examples.dao.DepartmentDao"&gt;
    &lt;aspect&gt;dao.interceptor&lt;/aspect&gt;
  &lt;/component&gt;
&lt;/components&gt;
</pre>
		<h5>実行ファイルの作成</h5>
		<ul>
			<li type="circle">org.seasar.framework.container.S2Container#create()メソッドの第1引数に作成したdiconファイル(DepartmentDao.dicon)のパスを指定してコンテナを作成します。</li>
			<li type="circle">org.seasar.framework.container.S2Container#getComponent()メソッドの第1引数にコンポーネントに登録したクラス名（DepartmentDao.class)を指定してコンポーネントを取得します。</li>
			<li type="circle">Daoに定義したメソッドを実行します。</li>
		</ul>
<pre>
package examples.dao;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class DepartmentDaoClient {

    private static final String PATH = "examples/dao/DepartmentDao.dicon";

    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        container.init();
        try {
            DepartmentDao dao = (DepartmentDao) container
                    .getComponent(DepartmentDao.class);

            Department dept = new Department();
            dept.setDeptno(99);
            dept.setDname("foo");
            dao.insert(dept);
            dept.setDname("bar");

            System.out.println("before update versionNo:" + dept.getVersionNo());
            dao.update(dept);
            System.out.println("after update versionNo:" + dept.getVersionNo());
            dao.delete(dept);
        } finally {
            container.destroy();
        }
    }
}
</pre>
		<h5>実行結果</h5>
<pre>
DEBUG 2004-09-09 19:22:10,588 [main] 物理的なコネクションを取得しました
DEBUG 2004-09-09 19:22:10,588 [main] 論理的なコネクションを取得しました
DEBUG 2004-09-09 19:22:11,447 [main] 論理的なコネクションを閉じました
DEBUG 2004-09-09 19:22:11,603 [main] 論理的なコネクションを取得しました
DEBUG 2004-09-09 19:22:11,603 [main] INSERT INTO DEPT (deptno, dname, versionNo, loc)
  VALUES(99, 'foo', 0, null)
DEBUG 2004-09-09 19:22:11,666 [main] 論理的なコネクションを閉じました
before update versionNo:0
DEBUG 2004-09-09 19:22:11,666 [main] 論理的なコネクションを取得しました
DEBUG 2004-09-09 19:22:11,666 [main] UPDATE DEPT SET dname = 'bar',
  versionNo = versionNo + 1, loc = null   WHERE deptno = 99 AND versionNo = 0
DEBUG 2004-09-09 19:22:11,666 [main] 論理的なコネクションを閉じました
after update versionNo:1
DEBUG 2004-09-09 19:22:11,666 [main] 論理的なコネクションを取得しました
DEBUG 2004-09-09 19:22:11,666 [main] DELETE FROM DEPT WHERE deptno = 99 AND versionNo = 1
DEBUG 2004-09-09 19:22:11,681 [main] 論理的なコネクションを閉じました
DEBUG 2004-09-09 19:22:11,681 [main] 物理的なコネクションを閉じました
</pre>
    	<p>出力結果を見ると、自動的にSQL文が発行されていることが分かります。またJavaBeans(Department)にはint型のプロパティversionNoが定義してあるので、
    	自動でversionNoの値が+1され、この値によって排他制御されていることがわかります。
    	updateメソッドを呼ぶ以前では、versionNoの値は0ですが、updateメソッドを呼び出した後では、値が1になります。<br />
    	この演習は、s2dao/src/examples/dao以下に用意されています。</p>

		<h3><a name="AutoSelectExample">自動で検索用SQL文を生成する場合のExample</a></h3>
    	<p>自動でSELECT文の生成と<a href="#Timestamp">Timestampによる自動排他制御</a>を行う演習です。SQLファイルの作成は不要です。また引数にDTOを使用するメソッドも定義してみましょう。
		作成するファイルは以下のとおりです。</p>
    	<ul>
    		<li type="circle">Dao(EmployeeAutoDao.java)</li>
    		<li type="circle">DTO(EmployeeSearchCondition.java)</li>
    		<li type="circle">diconファイル(EmployeeAutoDao.dicon)</li>
    		<li type="circle">実行クラス(EmployeeAutoDaoClient.java)</li>
    	</ul>
    	<h5>Daoの作成</h5>
    	<ul>
    		<li type="circle">EMPテーブルと対応するJavaBeansと関連付けをします。</li>
    		<li type="circle">メソッドを定義します。<br />
    		全件検索するメソッド(getAllEmployees()メソッド)<br />
    		仕事と部署番号を引数として、一致する従業員を検索するメソッド(getEmployeeByJobDeptno(String job, Integer deptno)メソッド)<br />
    		従業員番号を引数として、一致する従業員を検索するメソッド(getEmployeeByEmpno(int empno)メソッド)<br />
    		指定した給料の間に含まれる従業員を検索するメソッド(getEmployeesBySal(float minSal, float maxSal)メソッド)<br />
    		指定した部署と一致する従業員を検索するメソッド(getEmployeeByDname(String dname)メソッド)<br />
    		DTOを引数とした従業員の検索をするメソッド(getEmployeesBySearchCondition(EmployeeSearchCondition dto)メソッド)<br />
    		従業員を更新するメソッド(update(Employee employee)メソッド)
    		</li>
    	</ul>
<pre>
package examples.dao;

import java.util.List;

public interface EmployeeAutoDao {

    public Class BEAN = Employee.class;

    public List getAllEmployees();

    public String getEmployeeByJobDeptno_ARGS = "job, deptno";

    public List getEmployeeByJobDeptno(String job, Integer deptno);

    public String getEmployeeByEmpno_ARGS = "empno";

    public Employee getEmployeeByEmpno(int empno);

    public String getEmployeesBySal_QUERY = "sal BETWEEN ? AND ? ORDER BY empno";

    public List getEmployeesBySal(float minSal, float maxSal);

    public String getEmployeeByDname_ARGS = "dname_0";

    public List getEmployeeByDname(String dname);

    public List getEmployeesBySearchCondition(EmployeeSearchCondition dto);

    public void update(Employee employee);
}
</pre>
		<h5>DTOの作成</h5>
    	<ul>
    		<li type="circle"><a href="#COLUMNAnnotation">COLUMNアノテーション</a>でカラムとdnameプロパティを関連付けします。</li>
    		<li type="circle">プロパティの宣言をします。</li>
    	</ul>
<pre>
package examples.dao;

public class EmployeeSearchCondition {

    public static final String dname_COLUMN = "dname_0";
    private String job;
    private String dname;

    public String getDname() {
        return dname;
    }

    public void setDname(String dname) {
        this.dname = dname;
    }

    public String getJob() {
        return job;
    }

    public void setJob(String job) {
        this.job = job;
    }
}
</pre>
		<h5>diconファイルの作成</h5>
		<ul>
			<li type="circle">dao.diconをincludeします。</li>
			<li type="circle">作成したDaoのコンポーネント定義します。</li>
			<li type="circle">Daoにdao.interceptor(S2DaoInterceptor)を適用します。</li>
		</ul>
<pre>
&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container//EN"
"http://www.seasar.org/dtd/components.dtd"&gt;
&lt;components&gt;
  &lt;include path="dao.dicon"/&gt;
  &lt;component class="examples.dao.EmployeeAutoDao"&gt;
    &lt;aspect&gt;dao.interceptor&lt;/aspect&gt;
  &lt;/component&gt;
&lt;/components&gt;
</pre>
		<h5>実行ファイルの作成</h5>
		<ul>
			<li type="circle">org.seasar.framework.container.S2Container#create()メソッドの第1引数に作成したdiconファイル(EmployeeAutoDao.dicon)のパスを指定してコンテナを作成します。</li>
			<li type="circle">org.seasar.framework.container.S2Container#getComponent()メソッドの第1引数にコンポーネントに登録したクラス名（EmployeeAutoDao.class)を指定してコンポーネントを取得します。</li>
			<li type="circle">Daoに定義したメソッドを実行します。</li>
		</ul>
<pre>
package examples.dao;

import java.util.List;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class EmployeeAutoDaoClient {

    private static final String PATH = "examples/dao/EmployeeAutoDao.dicon";

    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        container.init();
        try {
            EmployeeAutoDao dao = (EmployeeAutoDao) container
                    .getComponent(EmployeeAutoDao.class);

            dao.getEmployeeByJobDeptno(null, null);
            dao.getEmployeeByJobDeptno("CLERK", null);
            dao.getEmployeeByJobDeptno(null, new Integer(20));
            dao.getEmployeeByJobDeptno("CLERK", new Integer(20));

            List employees = dao.getEmployeesBySal(0, 1000);
            for (int i = 0; i < employees.size(); ++i) {
                System.out.println(employees.get(i));
            }

            employees = dao.getEmployeeByDname("SALES");
            for (int i = 0; i < employees.size(); ++i) {
                System.out.println(employees.get(i));
            }

            EmployeeSearchCondition dto = new EmployeeSearchCondition();
            dto.setDname("RESEARCH");
            employees = dao.getEmployeesBySearchCondition(dto);
            for (int i = 0; i < employees.size(); ++i) {
                System.out.println(employees.get(i));
            }

            Employee employee = dao.getEmployeeByEmpno(7788);
            System.out.println("before timestamp:" + employee.getTimestamp());
            dao.update(employee);
            System.out.println("after timestamp:" + employee.getTimestamp());
        } finally {
            container.destroy();
        }

    }
}
</pre>
		<h5>実行結果</h5>
<pre>
DEBUG 2004-10-12 11:35:22,054 [main] 物理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:22,069 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:22,897 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:35:23,726 [main] SELECT EMP.tstamp, EMP.empno, EMP.ename, EMP.job, EMP.mgr,
EMP.hiredate, EMP.sal, EMP.comm, EMP.deptno, department.dname AS dname_0, department.deptno AS deptno_0,
department.loc AS loc_0, department.versionNo AS versionNo_0 FROM EMP LEFT OUTER JOIN DEPT department
ON EMP.deptno = department.deptno
DEBUG 2004-10-12 11:35:23,726 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:23,866 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:35:23,866 [main] SELECT EMP.tstamp, EMP.empno, EMP.ename, EMP.job, EMP.mgr,
EMP.hiredate, EMP.sal, EMP.comm, EMP.deptno, department.dname AS dname_0, department.deptno AS deptno_0,
department.loc AS loc_0, department.versionNo AS versionNo_0 FROM EMP LEFT OUTER JOIN DEPT department
ON EMP.deptno = department.deptno WHERE  EMP.job = 'CLERK'
DEBUG 2004-10-12 11:35:23,866 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:23,882 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:35:23,882 [main] SELECT EMP.tstamp, EMP.empno, EMP.ename, EMP.job, EMP.mgr,
EMP.hiredate, EMP.sal, EMP.comm, EMP.deptno, department.dname AS dname_0, department.deptno AS deptno_0,
department.loc AS loc_0, department.versionNo AS versionNo_0 FROM EMP LEFT OUTER JOIN DEPT department
ON EMP.deptno = department.deptno WHERE EMP.deptno = 20
DEBUG 2004-10-12 11:35:23,882 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:23,913 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:35:23,913 [main] SELECT EMP.tstamp, EMP.empno, EMP.ename, EMP.job, EMP.mgr,
EMP.hiredate, EMP.sal, EMP.comm, EMP.deptno, department.dname AS dname_0, department.deptno AS deptno_0,
department.loc AS loc_0, department.versionNo AS versionNo_0 FROM EMP LEFT OUTER JOIN DEPT department
ON EMP.deptno = department.deptno WHERE  EMP.job = 'CLERK' AND EMP.deptno = 20
DEBUG 2004-10-12 11:35:23,913 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:23,929 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-12 11:35:23,929 [main] SELECT EMP.tstamp, EMP.empno, EMP.ename, EMP.job, EMP.mgr,
EMP.hiredate, EMP.sal, EMP.comm, EMP.deptno, department.dname AS dname_0, department.deptno AS deptno_0,
department.loc AS loc_0, department.versionNo AS versionNo_0 FROM EMP LEFT OUTER JOIN DEPT department
ON EMP.deptno = department.deptno WHERE sal BETWEEN 0.0 AND 1000.0 ORDER BY empno
DEBUG 2004-10-12 11:35:23,929 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:23,944 [main] 論理的なコネクションを閉じました
7369, SMITH, CLERK, 7902, 1980-12-17 00:00:00.0, 800.0, null, 20, 1980-12-17 00:00:00.0
{20, RESEARCH, DALLAS, 0}
7900, JAMES, CLERK, 7698, 1981-12-03 00:00:00.0, 950.0, null, 30, 1980-12-17 00:00:00.0
{30, SALES, CHICAGO, 0}
DEBUG 2004-10-12 11:35:23,944 [main] SELECT EMP.tstamp, EMP.empno, EMP.ename, EMP.job, EMP.mgr,
EMP.hiredate, EMP.sal, EMP.comm, EMP.deptno, department.dname AS dname_0, department.deptno AS deptno_0,
department.loc AS loc_0, department.versionNo AS versionNo_0 FROM EMP LEFT OUTER JOIN DEPT department
ON EMP.deptno = department.deptno WHERE  department.dname = 'SALES'
DEBUG 2004-10-12 11:35:23,944 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:23,960 [main] 論理的なコネクションを閉じました
7499, ALLEN, SALESMAN, 7698, 1981-02-20 00:00:00.0, 1600.0, 300.0, 30, 1980-12-17 00:00:00.0
{30, SALES, CHICAGO, 0}
7521, WARD, SALESMAN, 7698, 1981-02-22 00:00:00.0, 1250.0, 500.0, 30, 1980-12-17 00:00:00.0
{30, SALES, CHICAGO, 0}
7654, MARTIN, SALESMAN, 7698, 1981-09-28 00:00:00.0, 1250.0, 1400.0, 30, 1980-12-17 00:00:00.0
{30, SALES, CHICAGO, 0}
7698, BLAKE, MANAGER, 7839, 1981-05-01 00:00:00.0, 2850.0, null, 30, 1980-12-17 00:00:00.0
{30, SALES, CHICAGO, 0}
7844, TURNER, SALESMAN, 7698, 1981-09-08 00:00:00.0, 1500.0, 0.0, 30, 1980-12-17 00:00:00.0
{30, SALES, CHICAGO, 0}
7900, JAMES, CLERK, 7698, 1981-12-03 00:00:00.0, 950.0, null, 30, 1980-12-17 00:00:00.0
{30, SALES, CHICAGO, 0}
DEBUG 2004-10-12 11:35:23,960 [main] SELECT EMP.tstamp, EMP.empno, EMP.ename, EMP.job, EMP.mgr,
EMP.hiredate, EMP.sal, EMP.comm, EMP.deptno, department.dname AS dname_0, department.deptno AS deptno_0,
department.loc AS loc_0, department.versionNo AS versionNo_0 FROM EMP LEFT OUTER JOIN DEPT department
ON EMP.deptno = department.deptno WHERE  department.dname = 'RESEARCH'
DEBUG 2004-10-12 11:35:23,976 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:23,976 [main] 論理的なコネクションを閉じました
7369, SMITH, CLERK, 7902, 1980-12-17 00:00:00.0, 800.0, null, 20, 1980-12-17 00:00:00.0
{20, RESEARCH, DALLAS, 0}
7566, JONES, MANAGER, 7839, 1981-04-02 00:00:00.0, 2975.0, null, 20, 1980-12-17 00:00:00.0
{20, RESEARCH, DALLAS, 0}
7788, SCOTT, ANALYST, 7566, 1982-12-09 00:00:00.0, 3000.0, null, 20, 2004-10-12 10:15:54.914
{20, RESEARCH, DALLAS, 0}
7876, ADAMS, CLERK, 7788, 1983-01-12 00:00:00.0, 1100.0, null, 20, 1980-12-17 00:00:00.0
{20, RESEARCH, DALLAS, 0}
7902, FORD, ANALYST, 7566, 1981-12-03 00:00:00.0, 3000.0, null, 20, 1980-12-17 00:00:00.0
{20, RESEARCH, DALLAS, 0}
DEBUG 2004-10-12 11:35:23,976 [main] SELECT EMP.tstamp, EMP.empno, EMP.ename, EMP.job, EMP.mgr,
EMP.hiredate, EMP.sal, EMP.comm, EMP.deptno, department.dname AS dname_0, department.deptno AS deptno_0,
department.loc AS loc_0, department.versionNo AS versionNo_0 FROM EMP LEFT OUTER JOIN DEPT department
ON EMP.deptno = department.deptno WHERE  EMP.empno = 7788
DEBUG 2004-10-12 11:35:23,991 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:23,991 [main] 論理的なコネクションを閉じました
before timestamp:2004-10-12 10:15:54.914
DEBUG 2004-10-12 11:35:23,991 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-12 11:35:23,991 [main] UPDATE EMP SET tstamp = '2004-10-12 11.35.23', ename = 'SCOTT',
job = 'ANALYST', mgr = 7566, hiredate = '1982-12-09 00.00.00', sal = 3000.0, comm = null, deptno = 20
WHERE empno = 7788 AND tstamp = '2004-10-12 10.15.54'
DEBUG 2004-10-12 11:35:24,054 [main] 論理的なコネクションを閉じました
after timestamp:2004-10-12 11:35:23.991
DEBUG 2004-10-12 11:35:24,054 [main] 物理的なコネクションを閉じました
</pre>
    	<p>出力されているログからSQL文が自動的に生成されていることがわかります。<br />
    	また更新前と更新後ではTimestampの値が変化していることに気付くと思います。この値で排他制御を行っていることがわかります。<br />
    	この演習は、s2dao/src/examples/dao以下に用意されています。</p>

		<h3><a name="EntityManagerExample">EntityManagerを使用したExample</a></h3>
		<p><a href="#EntityManager">EntityManager</a>を使用して、指定した文字列を名前に含む従業員を検索する演習です。<br />
		作成するファイルは以下のとおりです。</p>
    	<ul>
    		<li type="circle">Dao(Employee2Dao.java)</li>
    		<li type="circle">AbstractDaoを継承したクラス(Employee2DaoImpl.java)</li>
    		<li type="circle">diconファイル(Employee2Dao.dicon)</li>
    		<li type="circle">実行クラス(Employee2DaoClient.java)</li>
    	</ul>
    	<h5>Daoの作成</h5>
    	<ul>
    		<li type="circle">なお、インターフェース名は"Dao"で終わらす必要があります。</li>
    		<li type="circle">EMPテーブルと対応するJavaBeansと関連付けをします。</li>
    		<li type="circle">検索処理を行うメソッドを定義します。<br />
             従業員を検索するメソッド(getEmployees(String ename))
    		</li>
    	</ul>
<pre>
package examples.dao;

import java.util.List;

public interface Employee2Dao {

    public Class BEAN = Employee.class;

    public List getEmployees(String ename);
}
</pre>
	    <h5>AbstractDaoを継承したクラスの作成</h5>
    	<ul>
    		<li type="circle">org.seasar.dao.impl.AbstractDaoを継承します。</li>
    		<li type="circle">Employee2Daoをimplementsします。</li>
    		<li type="circle">getEmployeesメソッドを実装します。指定した文字列を名前に含む検索をします。</li>
    	</ul>
<pre>
package examples.dao;

import java.util.List;

import org.seasar.dao.DaoMetaDataFactory;
import org.seasar.dao.impl.AbstractDao;

public class Employee2DaoImpl extends AbstractDao implements Employee2Dao {

    public Employee2DaoImpl(DaoMetaDataFactory daoMetaDataFactory) {
        super(daoMetaDataFactory);
    }

    public List getEmployees(String ename) {
        return getEntityManager().find("ename LIKE ?", "%" + ename + "%");
    }
}
</pre>
		<h5>diconファイルの作成</h5>
		<ul>
			<li type="circle">dao.diconをincludeします。</li>
			<li type="circle">AbstractDaoを継承したクラスをコンポーネント定義します。</li>
			<li type="circle">登録したコンポーネントにdao.interceptor(S2DaoInterceptor)を適用します。</li>
		</ul>
<pre>
&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container//EN"
"http://www.seasar.org/dtd/components.dtd"&gt;
&lt;components&gt;
    &lt;include path="dao.dicon"/&gt;
    &lt;component class="examples.dao.Employee2DaoImpl"&gt;
        &lt;aspect&gt;dao.interceptor&lt;/aspect&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>
		<h5>実行ファイルの作成</h5>
		<ul>
			<li type="circle">org.seasar.framework.container.S2Container#create()メソッドの第1引数に作成したdiconファイル(Employee2Dao.dicon)のパスを指定してコンテナを作成します。</li>
			<li type="circle">org.seasar.framework.container.S2Container#getComponent()メソッドの第1引数にコンポーネントに登録したクラス名（Employee2Dao.class)を指定してコンポーネントを取得します。</li>
			<li type="circle">"CO"を名前に含むという条件を指定します。</li>
			<li type="circle">Daoに定義したメソッドを実行します。</li>
		</ul>
<pre>
package examples.dao;

import java.util.List;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class Employee2DaoClient {

    private static final String PATH = "examples/dao/Employee2Dao.dicon";

    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        container.init();
        try {
            Employee2Dao dao = (Employee2Dao) container
                    .getComponent(Employee2Dao.class);
            List employees = dao.getEmployees("CO");
            for (int i = 0; i < employees.size(); ++i) {
                System.out.println(employees.get(i));
            }
        } finally {
            container.destroy();
        }

    }
}
</pre>
		<h5>実行結果</h5>
<pre>
DEBUG 2004-10-01 10:14:39,333 [main] 物理的なコネクションを取得しました
DEBUG 2004-10-01 10:14:39,333 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-01 10:14:40,379 [main] 論理的なコネクションを閉じました
DEBUG 2004-10-01 10:14:41,254 [main] SELECT EMP.empno, EMP.ename, EMP.job, EMP.mgr, EMP.hiredate,
  EMP.sal, EMP.comm, EMP.deptno, department.deptno AS deptno_0, department.dname AS dname_0,
  department.loc AS loc_0, department.versionNo AS versionNo_0 FROM EMP
  LEFT OUTER JOIN DEPT department ON EMP.deptno = department.deptno WHERE ename LIKE '%CO%'
DEBUG 2004-10-01 10:14:41,270 [main] 論理的なコネクションを取得しました
DEBUG 2004-10-01 10:14:41,426 [main] 論理的なコネクションを閉じました
7788, SCOTT, ANALYST, 7566, 1982-12-09 00:00:00.0, 3000.0, null, 20 {20, RESEARCH, DALLAS, 0}
DEBUG 2004-10-01 10:14:41,442 [main] 物理的なコネクションを閉じました
</pre>
		<p>この演習は、s2dao/src/examples/dao以下に用意されています。</p>


<!-- document end -->
<!-- don't edit start -->
</td>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="30" width="14" src="images/spacer.gif" alt=""></td>
<td width="766"><img height="30" width="592" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
<td width="766" class="copyright">&copy; Copyright The Seasar Foundation and the others 2004-2005, all rights reserved.</td>
</tr></table>
<td class="backright" align="left" valign="top">&nbsp;</td></tr><tr>
<td class="backunder" align="left"  valign="top" width="780" height="16">&nbsp;</td>
<td class="backcorner" align="left" valign="top" height="16">&nbsp;</td>
</tr></table></body>
<!-- don't edit end -->
</html>
